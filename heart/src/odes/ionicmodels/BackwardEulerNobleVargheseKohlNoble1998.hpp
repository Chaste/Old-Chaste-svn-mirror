#ifndef _CML_noble_varghese_kohl_noble_1998_basic_backward_
#define _CML_noble_varghese_kohl_noble_1998_basic_backward_

/** @file
 *
 * Model: noble_varghese_kohl_noble_1998_basic
 *
 * Processed by pycml - CellML Tools in Python
 *     (translate: 4024, pycml: 4024)
 * on Wed Jul 16 15:08:14 2008
 *
 * <autogenerated>
 */

#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>
#include "AbstractBackwardEulerCardiacCell.hpp"
#include "AbstractStimulusFunction.hpp"

class BackwardEulerNobleVargheseKohlNoble1998 : public AbstractBackwardEulerCardiacCell<12>
{    
    friend class TestFastSlowBackwardEulerNoble98; // Friend class for the purposes of testing

private:
    /** Needed for serialization. */
    friend class boost::serialization::access;
    /**
     * Archive the member variables.
     *
     * @param archive
     * @param version
     */
    template<class Archive>
    void serialize(Archive & archive, const unsigned int version)
    {
        // This calls serialize on the base class.
        archive & boost::serialization::base_object<AbstractBackwardEulerCardiacCell<12> >(*this);
    }

public:
    BackwardEulerNobleVargheseKohlNoble1998(boost::shared_ptr<AbstractIvpOdeSolver> /* unused */,
                                            boost::shared_ptr<AbstractStimulusFunction> pIntracellularStimulus);

    BackwardEulerNobleVargheseKohlNoble1998(boost::shared_ptr<AbstractStimulusFunction> pIntracellularStimulus);

private:
    void MakeVars();
    
public:
    ~BackwardEulerNobleVargheseKohlNoble1998(void)
    {
    }

    void VerifyGatingVariables();

    void VerifyStateVariables();
    
    double GetIIonic();

    void ComputeResidual(const double rCurrentGuess[12], double rResidual[12]);

    void ComputeJacobian(const double rCurrentGuess[12], double rJacobian[12][12]);

protected:
    void UpdateTransmembranePotential(double var_environment__time);

    void ComputeOneStepExceptVoltage(double var_environment__time);

};


#include "TemplatedExport.hpp"
CHASTE_CLASS_EXPORT(BackwardEulerNobleVargheseKohlNoble1998)

namespace boost
{
namespace serialization
{
/**
 * Allow us to not need a default constructor, by specifying how Boost should
 * instantiate a BackwardEulerNobleVargheseKohlNoble1998 instance.
 */
template<class Archive>
inline void save_construct_data(
    Archive & ar, const BackwardEulerNobleVargheseKohlNoble1998 * t, const unsigned int file_version)
{    
    const boost::shared_ptr<AbstractIvpOdeSolver> p_solver = t->GetSolver();
    const boost::shared_ptr<AbstractStimulusFunction> p_stimulus = t->GetStimulusFunction();
    ar << p_solver;
    ar << p_stimulus;
}

/**
 * Allow us to not need a default constructor, by specifying how Boost should
 * instantiate a BackwardEulerNobleVargheseKohlNoble1998 instance (using existing constructor).
 */
template<class Archive>
inline void load_construct_data(
    Archive & ar, BackwardEulerNobleVargheseKohlNoble1998 * t, const unsigned int file_version)
{
    boost::shared_ptr<AbstractIvpOdeSolver> p_solver;
    boost::shared_ptr<AbstractStimulusFunction> p_stimulus;
    ar >> p_solver;
    ar >> p_stimulus;
    ::new(t)BackwardEulerNobleVargheseKohlNoble1998(p_solver, p_stimulus);
}
}
} // namespace ...


#endif
