#ifndef _FaberRudy2000Version3_
#define _FaberRudy2000Version3_

/** @file
 *
 * Model: LR_Dynamic_model_2000
 *
 * Processed by pycml - CellML Tools in Python
 *     (translate: 1004, pycml: 896)
 * on Thu Dec 13 17:50:34 2007
 *
 * <autogenerated>
 */

#include "ChasteSerialization.hpp"
#include <boost/serialization/base_object.hpp>
#include <cmath>
#include <cassert>
#include "AbstractCardiacCell.hpp"
#include "Exception.hpp"
#include "AbstractStimulusFunction.hpp"
#include "OdeSystemInformation.hpp"

class FaberRudy2000Version3 : public AbstractCardiacCell
{
private:
    /** Scale factor for Gks*/
    double mScaleFactorGks;
    /** Scale factor for Gto*/
    double mScaleFactorIto;
    /** Scale factor for Gkr*/
    double mScaleFactorGkr;

    /** Needed for serialization. */
    friend class boost::serialization::access;
    /**
     * Archive the member variables.
     *
     * @param archive
     * @param version
     */
    template<class Archive>
    void serialize(Archive & archive, const unsigned int version)
    {
        // This calls serialize on the base class.
        archive & boost::serialization::base_object<AbstractCardiacCell>(*this);
    }

public:
    /**
     * Constructor
     * 
     * @param pSolver is a pointer to the ODE solver
     * @param pIntracellularStimulus is a pointer to the intracellular stimulus
     */
    FaberRudy2000Version3(boost::shared_ptr<AbstractIvpOdeSolver> pSolver,
                          boost::shared_ptr<AbstractStimulusFunction> pIntracellularStimulus);

    /**
     * Destructor
     */
    ~FaberRudy2000Version3(void);
    
    /**
     * Set the scale factor for Gks
     * @param sfgks
     */
    void SetScaleFactorGks(double sfgks);

    /**
     * Set the scale factor for Ito
     * @param sfito
     */
    void SetScaleFactorIto(double sfito);

    /**
     * Set the scale factor for Gkr (might be useful for simulating LQT2)
     * @param sfgkr
     */
    void SetScaleFactorGkr(double sfgkr);

    /**
     * Calculates the ionic current
     * 
     * @returns the total ionic current
     */
    double GetIIonic();

    /**
     * Evaluate the derivatives of the state variables
     * 
     * @param var_Environment__time  the current time, in milliseconds
     * @param rY  current values of the state variables
     * @param rDY  to be filled in with derivatives
     */
    void EvaluateYDerivatives (
            double var_environment__time,
            const std::vector<double> &rY,
            std::vector<double> &rDY);


};

// Must be last
#include "SerializationExportWrapper.hpp"
CHASTE_CLASS_EXPORT(FaberRudy2000Version3)

namespace boost
{
namespace serialization
{
/**
 * Allow us to not need a default constructor, by saving the data to pass to our normal constructor.
 */
template<class Archive>
inline void save_construct_data(
    Archive & ar, const FaberRudy2000Version3 * t, const unsigned int file_version)
{    
    const boost::shared_ptr<AbstractIvpOdeSolver> p_solver = t->GetSolver();
    const boost::shared_ptr<AbstractStimulusFunction> p_stimulus = t->GetStimulusFunction();
    ar << p_solver;
    ar << p_stimulus;
}

/**
 * Allow us to not need a default constructor, by specifying how Boost should
 * instantiate an instance (using existing constructor).
 */
template<class Archive>
inline void load_construct_data(
    Archive & ar, FaberRudy2000Version3 * t, const unsigned int file_version)
{
    boost::shared_ptr<AbstractIvpOdeSolver> p_solver;
    boost::shared_ptr<AbstractStimulusFunction> p_stimulus;
    ar >> p_solver;
    ar >> p_stimulus;
    ::new(t)FaberRudy2000Version3(p_solver, p_stimulus);
}
}
} // namespace ...


#endif
