#ifndef _MALECKAR2009ODESYSTEM_
#define _MALECKAR2009ODESYSTEM_

//! @file
//! 
//! This source file was generated from CellML.
//! 
//! Model: Maleckar
//! 
//! Processed by pycml - CellML Tools in Python
//!     (translate: 7385, pycml: 7152)
//! on Mon Dec 14 15:22:44 2009
//! 
//! <autogenerated>

#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>
#include <cmath>
#include <cassert>
#include "AbstractCardiacCell.hpp"
#include "Exception.hpp"
#include "OdeSystemInformation.hpp"
#include "AbstractStimulusFunction.hpp"
/**
 * This class implements the Maleckar 2009 cell model
 * The code has been translated by PyCml.
 * Some scale factors have been manually added to be used to simulate the efefct of some drug
 * By default, it behaves in a 'control' situation i.e., like the file downloaded from the CellML repository
 * 
 */
class Maleckar2009OdeSystem : public AbstractCardiacCell
{
    
private:
    /** Scale factor for Gks*/
    double mScaleFactorGks;
    /** Scale factor for Gto*/
    double mScaleFactorIto;
    /** Scale factor for Gkr*/
    double mScaleFactorGkr;
    /** Scale factor for Gna*/
    double mScaleFactorGna;
    /** Scale factor for Ach*/
    double mScaleFactorAch;
    /** Scale factor for NaK*/
    double mScaleFactorGNaK;
    /** Scale factor for NaCa*/
    double mScaleFactorGNaCa;
    /** Scale factor for CaL*/
    double mScaleFactorGCaL;
    /** Scale factor for Kur*/
    double mScaleFactorGKur;
    /** Scale factor for GK1*/
    double mScaleFactorGK1;
    /** Scale factor for AZD*/
    double mScaleFactorAZD;
    
    /** Needed for serialization. */
    friend class boost::serialization::access;
    
    /**
     * Archive the member variables.
     *
     * @param archive
     * @param version
     */
    template<class Archive>
    void serialize(Archive & archive, const unsigned int version)
    {
        archive & boost::serialization::base_object<AbstractCardiacCell>(*this);
    }
    
public:

    /**
     * Constructor
     * 
     * @param pSolver is a pointer to the ODE solver
     * @param pIntracellularStimulus is a pointer to the intracellular stimulus
     */
    Maleckar2009OdeSystem(boost::shared_ptr<AbstractIvpOdeSolver> pSolver, 
                 boost::shared_ptr<AbstractStimulusFunction> pIntracellularStimulus);
                 
    /**
     * Destructor
     */   
    ~Maleckar2009OdeSystem(void);

    /**
     * Set the scale factor for Gks in order to differentiate epi M and endo cells
     * @param sfgks
     */
    void SetScaleFactorGks(double sfgks);
    void SetScaleFactorIto(double sfito);
    void SetScaleFactorGkr(double sfgkr);
    void SetScaleFactorGna(double sfgna);
    void SetScaleFactorAch(double sfach);
    void SetScaleFactorGNaK(double sfgnak);
    void SetScaleFactorGNaCa(double sfgnaca);
    void SetScaleFactorGCaL(double sfgcal);
    void SetScaleFactorGKur(double sfgkur);
    void SetScaleFactorGK1(double sfgk1);
    void SetScaleFactorAZD(double sfazd);
    
    /**
     *  Range-checking on the current values of the state variables. Make sure
     *  all gating variables have are within zero and one, and all concentrations
     *  are positive. 
     * 
     *  ///\ TODO : implement this!
     */
    void VerifyGatingVariables();

    /**
     * Returns the ionic current
     * 
     * @return the total ionic current
     */
    double GetIIonic();

    /**
     * Fill in a vector representing the RHS of the TenTusscher2006 system
     * of Odes at each time step, y' = [y1' ... yn'].
     * Some ODE solver will call this function repeatedly to solve for y = [y1 ... yn].
     *
     * @param time  the current time, in milliseconds
     * @param rY  current values of the state variables
     * @param rDY  to be filled in with derivatives
     */    
    void EvaluateYDerivatives(
            double var_environment__time,
            const std::vector<double> &rY,
            std::vector<double> &rDY);
    
};

// Needs to be included last
#include "TemplatedExport.hpp"
CHASTE_CLASS_EXPORT(Maleckar2009OdeSystem)

namespace boost
{
    namespace serialization
    {
        template<class Archive>
        inline void save_construct_data(
            Archive & ar, const Maleckar2009OdeSystem * t, const unsigned int fileVersion)
        {
            const boost::shared_ptr<AbstractIvpOdeSolver> p_solver = t->GetSolver();
            const boost::shared_ptr<AbstractStimulusFunction> p_stimulus = t->GetStimulusFunction();
            ar << p_solver;
            ar << p_stimulus;
        }
        
        template<class Archive>
        inline void load_construct_data(
            Archive & ar, Maleckar2009OdeSystem * t, const unsigned int fileVersion)
        {
            boost::shared_ptr<AbstractIvpOdeSolver> p_solver;
            boost::shared_ptr<AbstractStimulusFunction> p_stimulus;
            ar >> p_solver;
            ar >> p_stimulus;
            ::new(t)Maleckar2009OdeSystem(p_solver, p_stimulus);
        }
        
    }
    
}

#endif
