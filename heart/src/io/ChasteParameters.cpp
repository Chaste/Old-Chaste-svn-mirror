// Copyright (C) 2005-2007 Code Synthesis Tools CC
//
// This program was generated by XML Schema Definition Compiler (XSD)
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
#define COVERAGE_IGNORE
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "ChasteParameters.hpp"

// time_type
//

const time_type::unit::type& time_type::unit::
default_value ()
{
  return default_value_;
}

const time_type::unit::type& time_type::
unit () const
{
  return this->_xsd_unit_.get ();
}

time_type::unit::type& time_type::
unit ()
{
  return this->_xsd_unit_.get ();
}

void time_type::
unit (const unit::type& unit)
{
  this->_xsd_unit_.set (unit);
}

void time_type::
unit (::std::auto_ptr< unit::type > unit)
{
  this->_xsd_unit_.set (unit);
}


// dimensionless_type
//

const dimensionless_type::unit::type& dimensionless_type::unit::
default_value ()
{
  return default_value_;
}

const dimensionless_type::unit::type& dimensionless_type::
unit () const
{
  return this->_xsd_unit_.get ();
}

dimensionless_type::unit::type& dimensionless_type::
unit ()
{
  return this->_xsd_unit_.get ();
}

void dimensionless_type::
unit (const unit::type& unit)
{
  this->_xsd_unit_.set (unit);
}

void dimensionless_type::
unit (::std::auto_ptr< unit::type > unit)
{
  this->_xsd_unit_.set (unit);
}


// conductivity_type
//

const conductivity_type::unit::type& conductivity_type::unit::
default_value ()
{
  return default_value_;
}

const conductivity_type::unit::type& conductivity_type::
unit () const
{
  return this->_xsd_unit_.get ();
}

conductivity_type::unit::type& conductivity_type::
unit ()
{
  return this->_xsd_unit_.get ();
}

void conductivity_type::
unit (const unit::type& unit)
{
  this->_xsd_unit_.set (unit);
}

void conductivity_type::
unit (::std::auto_ptr< unit::type > unit)
{
  this->_xsd_unit_.set (unit);
}


// stimulus_strength_type
//

const stimulus_strength_type::unit::type& stimulus_strength_type::unit::
default_value ()
{
  return default_value_;
}

const stimulus_strength_type::unit::type& stimulus_strength_type::
unit () const
{
  return this->_xsd_unit_.get ();
}

stimulus_strength_type::unit::type& stimulus_strength_type::
unit ()
{
  return this->_xsd_unit_.get ();
}

void stimulus_strength_type::
unit (const unit::type& unit)
{
  this->_xsd_unit_.set (unit);
}

void stimulus_strength_type::
unit (::std::auto_ptr< unit::type > unit)
{
  this->_xsd_unit_.set (unit);
}


// inverse_length_type
//

const inverse_length_type::unit::type& inverse_length_type::unit::
default_value ()
{
  return default_value_;
}

const inverse_length_type::unit::type& inverse_length_type::
unit () const
{
  return this->_xsd_unit_.get ();
}

inverse_length_type::unit::type& inverse_length_type::
unit ()
{
  return this->_xsd_unit_.get ();
}

void inverse_length_type::
unit (const unit::type& unit)
{
  this->_xsd_unit_.set (unit);
}

void inverse_length_type::
unit (::std::auto_ptr< unit::type > unit)
{
  this->_xsd_unit_.set (unit);
}


// capacitance_type
//

const capacitance_type::unit::type& capacitance_type::unit::
default_value ()
{
  return default_value_;
}

const capacitance_type::unit::type& capacitance_type::
unit () const
{
  return this->_xsd_unit_.get ();
}

capacitance_type::unit::type& capacitance_type::
unit ()
{
  return this->_xsd_unit_.get ();
}

void capacitance_type::
unit (const unit::type& unit)
{
  this->_xsd_unit_.set (unit);
}

void capacitance_type::
unit (::std::auto_ptr< unit::type > unit)
{
  this->_xsd_unit_.set (unit);
}


// location_type
//

const location_type::Cuboid::type& location_type::
Cuboid () const
{
  return this->_xsd_Cuboid_.get ();
}

location_type::Cuboid::type& location_type::
Cuboid ()
{
  return this->_xsd_Cuboid_.get ();
}

void location_type::
Cuboid (const Cuboid::type& Cuboid)
{
  this->_xsd_Cuboid_.set (Cuboid);
}

void location_type::
Cuboid (::std::auto_ptr< Cuboid::type > Cuboid)
{
  this->_xsd_Cuboid_.set (Cuboid);
}

const location_type::unit::type& location_type::unit::
default_value ()
{
  return default_value_;
}

const location_type::unit::type& location_type::
unit () const
{
  return this->_xsd_unit_.get ();
}

location_type::unit::type& location_type::
unit ()
{
  return this->_xsd_unit_.get ();
}

void location_type::
unit (const unit::type& unit)
{
  this->_xsd_unit_.set (unit);
}

void location_type::
unit (::std::auto_ptr< unit::type > unit)
{
  this->_xsd_unit_.set (unit);
}


// domain_type
//

domain_type::
domain_type (_xsd_domain_type v)
: ::xml_schema::string (_xsd_domain_type_literals_[v])
{
}

domain_type::
domain_type (const ::xml_schema::string& _xsd_domain_type)
: ::xml_schema::string (_xsd_domain_type)
{
}

domain_type::
domain_type (const domain_type& v,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
: ::xml_schema::string (v, f, c)
{
}

domain_type& domain_type::
operator= (_xsd_domain_type v)
{
  static_cast< ::xml_schema::string& > (*this) =
  ::xml_schema::string (_xsd_domain_type_literals_[v]);

  return *this;
}


// ionic_models_available_type
//

ionic_models_available_type::
ionic_models_available_type (_xsd_ionic_models_available_type v)
: ::xml_schema::string (_xsd_ionic_models_available_type_literals_[v])
{
}

ionic_models_available_type::
ionic_models_available_type (const ::xml_schema::string& _xsd_ionic_models_available_type)
: ::xml_schema::string (_xsd_ionic_models_available_type)
{
}

ionic_models_available_type::
ionic_models_available_type (const ionic_models_available_type& v,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
: ::xml_schema::string (v, f, c)
{
}

ionic_models_available_type& ionic_models_available_type::
operator= (_xsd_ionic_models_available_type v)
{
  static_cast< ::xml_schema::string& > (*this) =
  ::xml_schema::string (_xsd_ionic_models_available_type_literals_[v]);

  return *this;
}


// ionic_model_region_type
//

const ionic_model_region_type::IonicModel::type& ionic_model_region_type::
IonicModel () const
{
  return this->_xsd_IonicModel_.get ();
}

ionic_model_region_type::IonicModel::type& ionic_model_region_type::
IonicModel ()
{
  return this->_xsd_IonicModel_.get ();
}

void ionic_model_region_type::
IonicModel (const IonicModel::type& IonicModel)
{
  this->_xsd_IonicModel_.set (IonicModel);
}

void ionic_model_region_type::
IonicModel (::std::auto_ptr< IonicModel::type > IonicModel)
{
  this->_xsd_IonicModel_.set (IonicModel);
}

const ionic_model_region_type::Location::type& ionic_model_region_type::
Location () const
{
  return this->_xsd_Location_.get ();
}

ionic_model_region_type::Location::type& ionic_model_region_type::
Location ()
{
  return this->_xsd_Location_.get ();
}

void ionic_model_region_type::
Location (const Location::type& Location)
{
  this->_xsd_Location_.set (Location);
}

void ionic_model_region_type::
Location (::std::auto_ptr< Location::type > Location)
{
  this->_xsd_Location_.set (Location);
}


// ionic_models_type
//

const ionic_models_type::Default::type& ionic_models_type::
Default () const
{
  return this->_xsd_Default_.get ();
}

ionic_models_type::Default::type& ionic_models_type::
Default ()
{
  return this->_xsd_Default_.get ();
}

void ionic_models_type::
Default (const Default::type& Default)
{
  this->_xsd_Default_.set (Default);
}

void ionic_models_type::
Default (::std::auto_ptr< Default::type > Default)
{
  this->_xsd_Default_.set (Default);
}

const ionic_models_type::Region::container& ionic_models_type::
Region () const
{
  return this->_xsd_Region_;
}

ionic_models_type::Region::container& ionic_models_type::
Region ()
{
  return this->_xsd_Region_;
}

void ionic_models_type::
Region (const Region::container& Region)
{
  this->_xsd_Region_ = Region;
}


// media_type
//

media_type::
media_type (_xsd_media_type v)
: ::xml_schema::string (_xsd_media_type_literals_[v])
{
}

media_type::
media_type (const ::xml_schema::string& _xsd_media_type)
: ::xml_schema::string (_xsd_media_type)
{
}

media_type::
media_type (const media_type& v,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::string (v, f, c)
{
}

media_type& media_type::
operator= (_xsd_media_type v)
{
  static_cast< ::xml_schema::string& > (*this) =
  ::xml_schema::string (_xsd_media_type_literals_[v]);

  return *this;
}


// point_type
//

const point_type::x::type& point_type::
x () const
{
  return this->_xsd_x_.get ();
}

point_type::x::type& point_type::
x ()
{
  return this->_xsd_x_.get ();
}

void point_type::
x (const x::type& x)
{
  this->_xsd_x_.set (x);
}

const point_type::y::type& point_type::
y () const
{
  return this->_xsd_y_.get ();
}

point_type::y::type& point_type::
y ()
{
  return this->_xsd_y_.get ();
}

void point_type::
y (const y::type& y)
{
  this->_xsd_y_.set (y);
}

const point_type::z::type& point_type::
z () const
{
  return this->_xsd_z_.get ();
}

point_type::z::type& point_type::
z ()
{
  return this->_xsd_z_.get ();
}

void point_type::
z (const z::type& z)
{
  this->_xsd_z_.set (z);
}


// box_type
//

const box_type::LowerCoordinates::type& box_type::
LowerCoordinates () const
{
  return this->_xsd_LowerCoordinates_.get ();
}

box_type::LowerCoordinates::type& box_type::
LowerCoordinates ()
{
  return this->_xsd_LowerCoordinates_.get ();
}

void box_type::
LowerCoordinates (const LowerCoordinates::type& LowerCoordinates)
{
  this->_xsd_LowerCoordinates_.set (LowerCoordinates);
}

void box_type::
LowerCoordinates (::std::auto_ptr< LowerCoordinates::type > LowerCoordinates)
{
  this->_xsd_LowerCoordinates_.set (LowerCoordinates);
}

const box_type::UpperCoordinates::type& box_type::
UpperCoordinates () const
{
  return this->_xsd_UpperCoordinates_.get ();
}

box_type::UpperCoordinates::type& box_type::
UpperCoordinates ()
{
  return this->_xsd_UpperCoordinates_.get ();
}

void box_type::
UpperCoordinates (const UpperCoordinates::type& UpperCoordinates)
{
  this->_xsd_UpperCoordinates_.set (UpperCoordinates);
}

void box_type::
UpperCoordinates (::std::auto_ptr< UpperCoordinates::type > UpperCoordinates)
{
  this->_xsd_UpperCoordinates_.set (UpperCoordinates);
}


// stimulus_type
//

const stimulus_type::Strength::type& stimulus_type::
Strength () const
{
  return this->_xsd_Strength_.get ();
}

stimulus_type::Strength::type& stimulus_type::
Strength ()
{
  return this->_xsd_Strength_.get ();
}

void stimulus_type::
Strength (const Strength::type& Strength)
{
  this->_xsd_Strength_.set (Strength);
}

void stimulus_type::
Strength (::std::auto_ptr< Strength::type > Strength)
{
  this->_xsd_Strength_.set (Strength);
}

const stimulus_type::Duration::type& stimulus_type::
Duration () const
{
  return this->_xsd_Duration_.get ();
}

stimulus_type::Duration::type& stimulus_type::
Duration ()
{
  return this->_xsd_Duration_.get ();
}

void stimulus_type::
Duration (const Duration::type& Duration)
{
  this->_xsd_Duration_.set (Duration);
}

void stimulus_type::
Duration (::std::auto_ptr< Duration::type > Duration)
{
  this->_xsd_Duration_.set (Duration);
}

const stimulus_type::Delay::type& stimulus_type::
Delay () const
{
  return this->_xsd_Delay_.get ();
}

stimulus_type::Delay::type& stimulus_type::
Delay ()
{
  return this->_xsd_Delay_.get ();
}

void stimulus_type::
Delay (const Delay::type& Delay)
{
  this->_xsd_Delay_.set (Delay);
}

void stimulus_type::
Delay (::std::auto_ptr< Delay::type > Delay)
{
  this->_xsd_Delay_.set (Delay);
}

const stimulus_type::Location::type& stimulus_type::
Location () const
{
  return this->_xsd_Location_.get ();
}

stimulus_type::Location::type& stimulus_type::
Location ()
{
  return this->_xsd_Location_.get ();
}

void stimulus_type::
Location (const Location::type& Location)
{
  this->_xsd_Location_.set (Location);
}

void stimulus_type::
Location (::std::auto_ptr< Location::type > Location)
{
  this->_xsd_Location_.set (Location);
}


// cell_heterogeneity_type
//

const cell_heterogeneity_type::ScaleFactorGks::type& cell_heterogeneity_type::
ScaleFactorGks () const
{
  return this->_xsd_ScaleFactorGks_.get ();
}

cell_heterogeneity_type::ScaleFactorGks::type& cell_heterogeneity_type::
ScaleFactorGks ()
{
  return this->_xsd_ScaleFactorGks_.get ();
}

void cell_heterogeneity_type::
ScaleFactorGks (const ScaleFactorGks::type& ScaleFactorGks)
{
  this->_xsd_ScaleFactorGks_.set (ScaleFactorGks);
}

void cell_heterogeneity_type::
ScaleFactorGks (::std::auto_ptr< ScaleFactorGks::type > ScaleFactorGks)
{
  this->_xsd_ScaleFactorGks_.set (ScaleFactorGks);
}

const cell_heterogeneity_type::ScaleFactorIto::type& cell_heterogeneity_type::
ScaleFactorIto () const
{
  return this->_xsd_ScaleFactorIto_.get ();
}

cell_heterogeneity_type::ScaleFactorIto::type& cell_heterogeneity_type::
ScaleFactorIto ()
{
  return this->_xsd_ScaleFactorIto_.get ();
}

void cell_heterogeneity_type::
ScaleFactorIto (const ScaleFactorIto::type& ScaleFactorIto)
{
  this->_xsd_ScaleFactorIto_.set (ScaleFactorIto);
}

void cell_heterogeneity_type::
ScaleFactorIto (::std::auto_ptr< ScaleFactorIto::type > ScaleFactorIto)
{
  this->_xsd_ScaleFactorIto_.set (ScaleFactorIto);
}

const cell_heterogeneity_type::ScaleFactorGkr::type& cell_heterogeneity_type::
ScaleFactorGkr () const
{
  return this->_xsd_ScaleFactorGkr_.get ();
}

cell_heterogeneity_type::ScaleFactorGkr::type& cell_heterogeneity_type::
ScaleFactorGkr ()
{
  return this->_xsd_ScaleFactorGkr_.get ();
}

void cell_heterogeneity_type::
ScaleFactorGkr (const ScaleFactorGkr::type& ScaleFactorGkr)
{
  this->_xsd_ScaleFactorGkr_.set (ScaleFactorGkr);
}

void cell_heterogeneity_type::
ScaleFactorGkr (::std::auto_ptr< ScaleFactorGkr::type > ScaleFactorGkr)
{
  this->_xsd_ScaleFactorGkr_.set (ScaleFactorGkr);
}

const cell_heterogeneity_type::Location::type& cell_heterogeneity_type::
Location () const
{
  return this->_xsd_Location_.get ();
}

cell_heterogeneity_type::Location::type& cell_heterogeneity_type::
Location ()
{
  return this->_xsd_Location_.get ();
}

void cell_heterogeneity_type::
Location (const Location::type& Location)
{
  this->_xsd_Location_.set (Location);
}

void cell_heterogeneity_type::
Location (::std::auto_ptr< Location::type > Location)
{
  this->_xsd_Location_.set (Location);
}


// conductivity_heterogeneity_type
//

const conductivity_heterogeneity_type::IntracellularConductivities::container& conductivity_heterogeneity_type::
IntracellularConductivities () const
{
  return this->_xsd_IntracellularConductivities_;
}

conductivity_heterogeneity_type::IntracellularConductivities::container& conductivity_heterogeneity_type::
IntracellularConductivities ()
{
  return this->_xsd_IntracellularConductivities_;
}

void conductivity_heterogeneity_type::
IntracellularConductivities (const IntracellularConductivities::type& IntracellularConductivities)
{
  this->_xsd_IntracellularConductivities_.set (IntracellularConductivities);
}

void conductivity_heterogeneity_type::
IntracellularConductivities (const IntracellularConductivities::container& IntracellularConductivities)
{
  this->_xsd_IntracellularConductivities_ = IntracellularConductivities;
}

void conductivity_heterogeneity_type::
IntracellularConductivities (::std::auto_ptr< IntracellularConductivities::type > IntracellularConductivities)
{
  this->_xsd_IntracellularConductivities_.set (IntracellularConductivities);
}

const conductivity_heterogeneity_type::ExtracellularConductivities::container& conductivity_heterogeneity_type::
ExtracellularConductivities () const
{
  return this->_xsd_ExtracellularConductivities_;
}

conductivity_heterogeneity_type::ExtracellularConductivities::container& conductivity_heterogeneity_type::
ExtracellularConductivities ()
{
  return this->_xsd_ExtracellularConductivities_;
}

void conductivity_heterogeneity_type::
ExtracellularConductivities (const ExtracellularConductivities::type& ExtracellularConductivities)
{
  this->_xsd_ExtracellularConductivities_.set (ExtracellularConductivities);
}

void conductivity_heterogeneity_type::
ExtracellularConductivities (const ExtracellularConductivities::container& ExtracellularConductivities)
{
  this->_xsd_ExtracellularConductivities_ = ExtracellularConductivities;
}

void conductivity_heterogeneity_type::
ExtracellularConductivities (::std::auto_ptr< ExtracellularConductivities::type > ExtracellularConductivities)
{
  this->_xsd_ExtracellularConductivities_.set (ExtracellularConductivities);
}

const conductivity_heterogeneity_type::Location::type& conductivity_heterogeneity_type::
Location () const
{
  return this->_xsd_Location_.get ();
}

conductivity_heterogeneity_type::Location::type& conductivity_heterogeneity_type::
Location ()
{
  return this->_xsd_Location_.get ();
}

void conductivity_heterogeneity_type::
Location (const Location::type& Location)
{
  this->_xsd_Location_.set (Location);
}

void conductivity_heterogeneity_type::
Location (::std::auto_ptr< Location::type > Location)
{
  this->_xsd_Location_.set (Location);
}


// slab_type
//

const slab_type::x::type& slab_type::
x () const
{
  return this->_xsd_x_.get ();
}

slab_type::x::type& slab_type::
x ()
{
  return this->_xsd_x_.get ();
}

void slab_type::
x (const x::type& x)
{
  this->_xsd_x_.set (x);
}

const slab_type::y::type& slab_type::
y () const
{
  return this->_xsd_y_.get ();
}

slab_type::y::type& slab_type::
y ()
{
  return this->_xsd_y_.get ();
}

void slab_type::
y (const y::type& y)
{
  this->_xsd_y_.set (y);
}

const slab_type::z::type& slab_type::
z () const
{
  return this->_xsd_z_.get ();
}

slab_type::z::type& slab_type::
z ()
{
  return this->_xsd_z_.get ();
}

void slab_type::
z (const z::type& z)
{
  this->_xsd_z_.set (z);
}

const slab_type::inter_node_space::type& slab_type::
inter_node_space () const
{
  return this->_xsd_inter_node_space_.get ();
}

slab_type::inter_node_space::type& slab_type::
inter_node_space ()
{
  return this->_xsd_inter_node_space_.get ();
}

void slab_type::
inter_node_space (const inter_node_space::type& inter_node_space)
{
  this->_xsd_inter_node_space_.set (inter_node_space);
}


// sheet_type
//

const sheet_type::x::type& sheet_type::
x () const
{
  return this->_xsd_x_.get ();
}

sheet_type::x::type& sheet_type::
x ()
{
  return this->_xsd_x_.get ();
}

void sheet_type::
x (const x::type& x)
{
  this->_xsd_x_.set (x);
}

const sheet_type::y::type& sheet_type::
y () const
{
  return this->_xsd_y_.get ();
}

sheet_type::y::type& sheet_type::
y ()
{
  return this->_xsd_y_.get ();
}

void sheet_type::
y (const y::type& y)
{
  this->_xsd_y_.set (y);
}

const sheet_type::inter_node_space::type& sheet_type::
inter_node_space () const
{
  return this->_xsd_inter_node_space_.get ();
}

sheet_type::inter_node_space::type& sheet_type::
inter_node_space ()
{
  return this->_xsd_inter_node_space_.get ();
}

void sheet_type::
inter_node_space (const inter_node_space::type& inter_node_space)
{
  this->_xsd_inter_node_space_.set (inter_node_space);
}


// fibre_type
//

const fibre_type::x::type& fibre_type::
x () const
{
  return this->_xsd_x_.get ();
}

fibre_type::x::type& fibre_type::
x ()
{
  return this->_xsd_x_.get ();
}

void fibre_type::
x (const x::type& x)
{
  this->_xsd_x_.set (x);
}

const fibre_type::inter_node_space::type& fibre_type::
inter_node_space () const
{
  return this->_xsd_inter_node_space_.get ();
}

fibre_type::inter_node_space::type& fibre_type::
inter_node_space ()
{
  return this->_xsd_inter_node_space_.get ();
}

void fibre_type::
inter_node_space (const inter_node_space::type& inter_node_space)
{
  this->_xsd_inter_node_space_.set (inter_node_space);
}


// load_mesh_type
//

const load_mesh_type::name::type& load_mesh_type::
name () const
{
  return this->_xsd_name_.get ();
}

load_mesh_type::name::type& load_mesh_type::
name ()
{
  return this->_xsd_name_.get ();
}

void load_mesh_type::
name (const name::type& name)
{
  this->_xsd_name_.set (name);
}

void load_mesh_type::
name (::std::auto_ptr< name::type > name)
{
  this->_xsd_name_.set (name);
}

const load_mesh_type::conductivity_media::type& load_mesh_type::
conductivity_media () const
{
  return this->_xsd_conductivity_media_.get ();
}

load_mesh_type::conductivity_media::type& load_mesh_type::
conductivity_media ()
{
  return this->_xsd_conductivity_media_.get ();
}

void load_mesh_type::
conductivity_media (const conductivity_media::type& conductivity_media)
{
  this->_xsd_conductivity_media_.set (conductivity_media);
}

void load_mesh_type::
conductivity_media (::std::auto_ptr< conductivity_media::type > conductivity_media)
{
  this->_xsd_conductivity_media_.set (conductivity_media);
}


// mesh_type
//

const mesh_type::Slab::container& mesh_type::
Slab () const
{
  return this->_xsd_Slab_;
}

mesh_type::Slab::container& mesh_type::
Slab ()
{
  return this->_xsd_Slab_;
}

void mesh_type::
Slab (const Slab::type& Slab)
{
  this->_xsd_Slab_.set (Slab);
}

void mesh_type::
Slab (const Slab::container& Slab)
{
  this->_xsd_Slab_ = Slab;
}

void mesh_type::
Slab (::std::auto_ptr< Slab::type > Slab)
{
  this->_xsd_Slab_.set (Slab);
}

const mesh_type::Sheet::container& mesh_type::
Sheet () const
{
  return this->_xsd_Sheet_;
}

mesh_type::Sheet::container& mesh_type::
Sheet ()
{
  return this->_xsd_Sheet_;
}

void mesh_type::
Sheet (const Sheet::type& Sheet)
{
  this->_xsd_Sheet_.set (Sheet);
}

void mesh_type::
Sheet (const Sheet::container& Sheet)
{
  this->_xsd_Sheet_ = Sheet;
}

void mesh_type::
Sheet (::std::auto_ptr< Sheet::type > Sheet)
{
  this->_xsd_Sheet_.set (Sheet);
}

const mesh_type::Fibre::container& mesh_type::
Fibre () const
{
  return this->_xsd_Fibre_;
}

mesh_type::Fibre::container& mesh_type::
Fibre ()
{
  return this->_xsd_Fibre_;
}

void mesh_type::
Fibre (const Fibre::type& Fibre)
{
  this->_xsd_Fibre_.set (Fibre);
}

void mesh_type::
Fibre (const Fibre::container& Fibre)
{
  this->_xsd_Fibre_ = Fibre;
}

void mesh_type::
Fibre (::std::auto_ptr< Fibre::type > Fibre)
{
  this->_xsd_Fibre_.set (Fibre);
}

const mesh_type::LoadMesh::container& mesh_type::
LoadMesh () const
{
  return this->_xsd_LoadMesh_;
}

mesh_type::LoadMesh::container& mesh_type::
LoadMesh ()
{
  return this->_xsd_LoadMesh_;
}

void mesh_type::
LoadMesh (const LoadMesh::type& LoadMesh)
{
  this->_xsd_LoadMesh_.set (LoadMesh);
}

void mesh_type::
LoadMesh (const LoadMesh::container& LoadMesh)
{
  this->_xsd_LoadMesh_ = LoadMesh;
}

void mesh_type::
LoadMesh (::std::auto_ptr< LoadMesh::type > LoadMesh)
{
  this->_xsd_LoadMesh_.set (LoadMesh);
}

const mesh_type::unit::type& mesh_type::unit::
default_value ()
{
  return default_value_;
}

const mesh_type::unit::type& mesh_type::
unit () const
{
  return this->_xsd_unit_.get ();
}

mesh_type::unit::type& mesh_type::
unit ()
{
  return this->_xsd_unit_.get ();
}

void mesh_type::
unit (const unit::type& unit)
{
  this->_xsd_unit_.set (unit);
}

void mesh_type::
unit (::std::auto_ptr< unit::type > unit)
{
  this->_xsd_unit_.set (unit);
}


// conductivities_type
//

const conductivities_type::longi::type& conductivities_type::
longi () const
{
  return this->_xsd_longi_.get ();
}

conductivities_type::longi::type& conductivities_type::
longi ()
{
  return this->_xsd_longi_.get ();
}

void conductivities_type::
longi (const longi::type& longi)
{
  this->_xsd_longi_.set (longi);
}

const conductivities_type::trans::type& conductivities_type::
trans () const
{
  return this->_xsd_trans_.get ();
}

conductivities_type::trans::type& conductivities_type::
trans ()
{
  return this->_xsd_trans_.get ();
}

void conductivities_type::
trans (const trans::type& trans)
{
  this->_xsd_trans_.set (trans);
}

const conductivities_type::normal::type& conductivities_type::
normal () const
{
  return this->_xsd_normal_.get ();
}

conductivities_type::normal::type& conductivities_type::
normal ()
{
  return this->_xsd_normal_.get ();
}

void conductivities_type::
normal (const normal::type& normal)
{
  this->_xsd_normal_.set (normal);
}

const conductivities_type::unit::type& conductivities_type::unit::
default_value ()
{
  return default_value_;
}

const conductivities_type::unit::type& conductivities_type::
unit () const
{
  return this->_xsd_unit_.get ();
}

conductivities_type::unit::type& conductivities_type::
unit ()
{
  return this->_xsd_unit_.get ();
}

void conductivities_type::
unit (const unit::type& unit)
{
  this->_xsd_unit_.set (unit);
}

void conductivities_type::
unit (::std::auto_ptr< unit::type > unit)
{
  this->_xsd_unit_.set (unit);
}


// time_steps_type
//

const time_steps_type::ode::type& time_steps_type::
ode () const
{
  return this->_xsd_ode_.get ();
}

time_steps_type::ode::type& time_steps_type::
ode ()
{
  return this->_xsd_ode_.get ();
}

void time_steps_type::
ode (const ode::type& ode)
{
  this->_xsd_ode_.set (ode);
}

const time_steps_type::pde::type& time_steps_type::
pde () const
{
  return this->_xsd_pde_.get ();
}

time_steps_type::pde::type& time_steps_type::
pde ()
{
  return this->_xsd_pde_.get ();
}

void time_steps_type::
pde (const pde::type& pde)
{
  this->_xsd_pde_.set (pde);
}

const time_steps_type::printing::type& time_steps_type::
printing () const
{
  return this->_xsd_printing_.get ();
}

time_steps_type::printing::type& time_steps_type::
printing ()
{
  return this->_xsd_printing_.get ();
}

void time_steps_type::
printing (const printing::type& printing)
{
  this->_xsd_printing_.set (printing);
}

const time_steps_type::unit::type& time_steps_type::unit::
default_value ()
{
  return default_value_;
}

const time_steps_type::unit::type& time_steps_type::
unit () const
{
  return this->_xsd_unit_.get ();
}

time_steps_type::unit::type& time_steps_type::
unit ()
{
  return this->_xsd_unit_.get ();
}

void time_steps_type::
unit (const unit::type& unit)
{
  this->_xsd_unit_.set (unit);
}

void time_steps_type::
unit (::std::auto_ptr< unit::type > unit)
{
  this->_xsd_unit_.set (unit);
}


// ksp_use_type
//

ksp_use_type::
ksp_use_type (_xsd_ksp_use_type v)
: ::xml_schema::string (_xsd_ksp_use_type_literals_[v])
{
}

ksp_use_type::
ksp_use_type (const ::xml_schema::string& _xsd_ksp_use_type)
: ::xml_schema::string (_xsd_ksp_use_type)
{
}

ksp_use_type::
ksp_use_type (const ksp_use_type& v,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
: ::xml_schema::string (v, f, c)
{
}

ksp_use_type& ksp_use_type::
operator= (_xsd_ksp_use_type v)
{
  static_cast< ::xml_schema::string& > (*this) =
  ::xml_schema::string (_xsd_ksp_use_type_literals_[v]);

  return *this;
}


// ksp_tolerances_type
//

const ksp_tolerances_type::KSPRelative::container& ksp_tolerances_type::
KSPRelative () const
{
  return this->_xsd_KSPRelative_;
}

ksp_tolerances_type::KSPRelative::container& ksp_tolerances_type::
KSPRelative ()
{
  return this->_xsd_KSPRelative_;
}

void ksp_tolerances_type::
KSPRelative (const KSPRelative::type& KSPRelative)
{
  this->_xsd_KSPRelative_.set (KSPRelative);
}

void ksp_tolerances_type::
KSPRelative (const KSPRelative::container& KSPRelative)
{
  this->_xsd_KSPRelative_ = KSPRelative;
}

const ksp_tolerances_type::KSPAbsolute::container& ksp_tolerances_type::
KSPAbsolute () const
{
  return this->_xsd_KSPAbsolute_;
}

ksp_tolerances_type::KSPAbsolute::container& ksp_tolerances_type::
KSPAbsolute ()
{
  return this->_xsd_KSPAbsolute_;
}

void ksp_tolerances_type::
KSPAbsolute (const KSPAbsolute::type& KSPAbsolute)
{
  this->_xsd_KSPAbsolute_.set (KSPAbsolute);
}

void ksp_tolerances_type::
KSPAbsolute (const KSPAbsolute::container& KSPAbsolute)
{
  this->_xsd_KSPAbsolute_ = KSPAbsolute;
}


// ksp_solver_type
//

ksp_solver_type::
ksp_solver_type (_xsd_ksp_solver_type v)
: ::xml_schema::string (_xsd_ksp_solver_type_literals_[v])
{
}

ksp_solver_type::
ksp_solver_type (const ::xml_schema::string& _xsd_ksp_solver_type)
: ::xml_schema::string (_xsd_ksp_solver_type)
{
}

ksp_solver_type::
ksp_solver_type (const ksp_solver_type& v,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
: ::xml_schema::string (v, f, c)
{
}

ksp_solver_type& ksp_solver_type::
operator= (_xsd_ksp_solver_type v)
{
  static_cast< ::xml_schema::string& > (*this) =
  ::xml_schema::string (_xsd_ksp_solver_type_literals_[v]);

  return *this;
}


// ksp_preconditioner_type
//

ksp_preconditioner_type::
ksp_preconditioner_type (_xsd_ksp_preconditioner_type v)
: ::xml_schema::string (_xsd_ksp_preconditioner_type_literals_[v])
{
}

ksp_preconditioner_type::
ksp_preconditioner_type (const ::xml_schema::string& _xsd_ksp_preconditioner_type)
: ::xml_schema::string (_xsd_ksp_preconditioner_type)
{
}

ksp_preconditioner_type::
ksp_preconditioner_type (const ksp_preconditioner_type& v,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
: ::xml_schema::string (v, f, c)
{
}

ksp_preconditioner_type& ksp_preconditioner_type::
operator= (_xsd_ksp_preconditioner_type v)
{
  static_cast< ::xml_schema::string& > (*this) =
  ::xml_schema::string (_xsd_ksp_preconditioner_type_literals_[v]);

  return *this;
}


// simulation_type
//

const simulation_type::SpaceDimension::container& simulation_type::
SpaceDimension () const
{
  return this->_xsd_SpaceDimension_;
}

simulation_type::SpaceDimension::container& simulation_type::
SpaceDimension ()
{
  return this->_xsd_SpaceDimension_;
}

void simulation_type::
SpaceDimension (const SpaceDimension::type& SpaceDimension)
{
  this->_xsd_SpaceDimension_.set (SpaceDimension);
}

void simulation_type::
SpaceDimension (const SpaceDimension::container& SpaceDimension)
{
  this->_xsd_SpaceDimension_ = SpaceDimension;
}

const simulation_type::SimulationDuration::container& simulation_type::
SimulationDuration () const
{
  return this->_xsd_SimulationDuration_;
}

simulation_type::SimulationDuration::container& simulation_type::
SimulationDuration ()
{
  return this->_xsd_SimulationDuration_;
}

void simulation_type::
SimulationDuration (const SimulationDuration::type& SimulationDuration)
{
  this->_xsd_SimulationDuration_.set (SimulationDuration);
}

void simulation_type::
SimulationDuration (const SimulationDuration::container& SimulationDuration)
{
  this->_xsd_SimulationDuration_ = SimulationDuration;
}

void simulation_type::
SimulationDuration (::std::auto_ptr< SimulationDuration::type > SimulationDuration)
{
  this->_xsd_SimulationDuration_.set (SimulationDuration);
}

const simulation_type::Domain::container& simulation_type::
Domain () const
{
  return this->_xsd_Domain_;
}

simulation_type::Domain::container& simulation_type::
Domain ()
{
  return this->_xsd_Domain_;
}

void simulation_type::
Domain (const Domain::type& Domain)
{
  this->_xsd_Domain_.set (Domain);
}

void simulation_type::
Domain (const Domain::container& Domain)
{
  this->_xsd_Domain_ = Domain;
}

void simulation_type::
Domain (::std::auto_ptr< Domain::type > Domain)
{
  this->_xsd_Domain_.set (Domain);
}

const simulation_type::Mesh::container& simulation_type::
Mesh () const
{
  return this->_xsd_Mesh_;
}

simulation_type::Mesh::container& simulation_type::
Mesh ()
{
  return this->_xsd_Mesh_;
}

void simulation_type::
Mesh (const Mesh::type& Mesh)
{
  this->_xsd_Mesh_.set (Mesh);
}

void simulation_type::
Mesh (const Mesh::container& Mesh)
{
  this->_xsd_Mesh_ = Mesh;
}

void simulation_type::
Mesh (::std::auto_ptr< Mesh::type > Mesh)
{
  this->_xsd_Mesh_.set (Mesh);
}

const simulation_type::IonicModels::container& simulation_type::
IonicModels () const
{
  return this->_xsd_IonicModels_;
}

simulation_type::IonicModels::container& simulation_type::
IonicModels ()
{
  return this->_xsd_IonicModels_;
}

void simulation_type::
IonicModels (const IonicModels::type& IonicModels)
{
  this->_xsd_IonicModels_.set (IonicModels);
}

void simulation_type::
IonicModels (const IonicModels::container& IonicModels)
{
  this->_xsd_IonicModels_ = IonicModels;
}

void simulation_type::
IonicModels (::std::auto_ptr< IonicModels::type > IonicModels)
{
  this->_xsd_IonicModels_.set (IonicModels);
}

// simulation_type::Stimuli::_xsd_Stimuli_::Stimuli
//

const simulation_type::Stimuli::_xsd_Stimuli_::Stimuli::Stimulus::container& simulation_type::Stimuli::_xsd_Stimuli_::Stimuli::
Stimulus () const
{
  return this->_xsd_Stimulus_;
}

simulation_type::Stimuli::_xsd_Stimuli_::Stimuli::Stimulus::container& simulation_type::Stimuli::_xsd_Stimuli_::Stimuli::
Stimulus ()
{
  return this->_xsd_Stimulus_;
}

void simulation_type::Stimuli::_xsd_Stimuli_::Stimuli::
Stimulus (const Stimulus::container& Stimulus)
{
  this->_xsd_Stimulus_ = Stimulus;
}


const simulation_type::Stimuli::container& simulation_type::
Stimuli () const
{
  return this->_xsd_Stimuli_;
}

simulation_type::Stimuli::container& simulation_type::
Stimuli ()
{
  return this->_xsd_Stimuli_;
}

void simulation_type::
Stimuli (const Stimuli::type& Stimuli)
{
  this->_xsd_Stimuli_.set (Stimuli);
}

void simulation_type::
Stimuli (const Stimuli::container& Stimuli)
{
  this->_xsd_Stimuli_ = Stimuli;
}

void simulation_type::
Stimuli (::std::auto_ptr< Stimuli::type > Stimuli)
{
  this->_xsd_Stimuli_.set (Stimuli);
}

// simulation_type::CellHeterogeneities::_xsd_CellHeterogeneities_::CellHeterogeneities
//

const simulation_type::CellHeterogeneities::_xsd_CellHeterogeneities_::CellHeterogeneities::CellHeterogeneity::container& simulation_type::CellHeterogeneities::_xsd_CellHeterogeneities_::CellHeterogeneities::
CellHeterogeneity () const
{
  return this->_xsd_CellHeterogeneity_;
}

simulation_type::CellHeterogeneities::_xsd_CellHeterogeneities_::CellHeterogeneities::CellHeterogeneity::container& simulation_type::CellHeterogeneities::_xsd_CellHeterogeneities_::CellHeterogeneities::
CellHeterogeneity ()
{
  return this->_xsd_CellHeterogeneity_;
}

void simulation_type::CellHeterogeneities::_xsd_CellHeterogeneities_::CellHeterogeneities::
CellHeterogeneity (const CellHeterogeneity::container& CellHeterogeneity)
{
  this->_xsd_CellHeterogeneity_ = CellHeterogeneity;
}


const simulation_type::CellHeterogeneities::container& simulation_type::
CellHeterogeneities () const
{
  return this->_xsd_CellHeterogeneities_;
}

simulation_type::CellHeterogeneities::container& simulation_type::
CellHeterogeneities ()
{
  return this->_xsd_CellHeterogeneities_;
}

void simulation_type::
CellHeterogeneities (const CellHeterogeneities::type& CellHeterogeneities)
{
  this->_xsd_CellHeterogeneities_.set (CellHeterogeneities);
}

void simulation_type::
CellHeterogeneities (const CellHeterogeneities::container& CellHeterogeneities)
{
  this->_xsd_CellHeterogeneities_ = CellHeterogeneities;
}

void simulation_type::
CellHeterogeneities (::std::auto_ptr< CellHeterogeneities::type > CellHeterogeneities)
{
  this->_xsd_CellHeterogeneities_.set (CellHeterogeneities);
}

// simulation_type::ConductivityHeterogeneities::_xsd_ConductivityHeterogeneities_::ConductivityHeterogeneities
//

const simulation_type::ConductivityHeterogeneities::_xsd_ConductivityHeterogeneities_::ConductivityHeterogeneities::ConductivityHeterogeneity::container& simulation_type::ConductivityHeterogeneities::_xsd_ConductivityHeterogeneities_::ConductivityHeterogeneities::
ConductivityHeterogeneity () const
{
  return this->_xsd_ConductivityHeterogeneity_;
}

simulation_type::ConductivityHeterogeneities::_xsd_ConductivityHeterogeneities_::ConductivityHeterogeneities::ConductivityHeterogeneity::container& simulation_type::ConductivityHeterogeneities::_xsd_ConductivityHeterogeneities_::ConductivityHeterogeneities::
ConductivityHeterogeneity ()
{
  return this->_xsd_ConductivityHeterogeneity_;
}

void simulation_type::ConductivityHeterogeneities::_xsd_ConductivityHeterogeneities_::ConductivityHeterogeneities::
ConductivityHeterogeneity (const ConductivityHeterogeneity::container& ConductivityHeterogeneity)
{
  this->_xsd_ConductivityHeterogeneity_ = ConductivityHeterogeneity;
}


const simulation_type::ConductivityHeterogeneities::container& simulation_type::
ConductivityHeterogeneities () const
{
  return this->_xsd_ConductivityHeterogeneities_;
}

simulation_type::ConductivityHeterogeneities::container& simulation_type::
ConductivityHeterogeneities ()
{
  return this->_xsd_ConductivityHeterogeneities_;
}

void simulation_type::
ConductivityHeterogeneities (const ConductivityHeterogeneities::type& ConductivityHeterogeneities)
{
  this->_xsd_ConductivityHeterogeneities_.set (ConductivityHeterogeneities);
}

void simulation_type::
ConductivityHeterogeneities (const ConductivityHeterogeneities::container& ConductivityHeterogeneities)
{
  this->_xsd_ConductivityHeterogeneities_ = ConductivityHeterogeneities;
}

void simulation_type::
ConductivityHeterogeneities (::std::auto_ptr< ConductivityHeterogeneities::type > ConductivityHeterogeneities)
{
  this->_xsd_ConductivityHeterogeneities_.set (ConductivityHeterogeneities);
}

const simulation_type::OutputDirectory::container& simulation_type::
OutputDirectory () const
{
  return this->_xsd_OutputDirectory_;
}

simulation_type::OutputDirectory::container& simulation_type::
OutputDirectory ()
{
  return this->_xsd_OutputDirectory_;
}

void simulation_type::
OutputDirectory (const OutputDirectory::type& OutputDirectory)
{
  this->_xsd_OutputDirectory_.set (OutputDirectory);
}

void simulation_type::
OutputDirectory (const OutputDirectory::container& OutputDirectory)
{
  this->_xsd_OutputDirectory_ = OutputDirectory;
}

void simulation_type::
OutputDirectory (::std::auto_ptr< OutputDirectory::type > OutputDirectory)
{
  this->_xsd_OutputDirectory_.set (OutputDirectory);
}

const simulation_type::OutputFilenamePrefix::container& simulation_type::
OutputFilenamePrefix () const
{
  return this->_xsd_OutputFilenamePrefix_;
}

simulation_type::OutputFilenamePrefix::container& simulation_type::
OutputFilenamePrefix ()
{
  return this->_xsd_OutputFilenamePrefix_;
}

void simulation_type::
OutputFilenamePrefix (const OutputFilenamePrefix::type& OutputFilenamePrefix)
{
  this->_xsd_OutputFilenamePrefix_.set (OutputFilenamePrefix);
}

void simulation_type::
OutputFilenamePrefix (const OutputFilenamePrefix::container& OutputFilenamePrefix)
{
  this->_xsd_OutputFilenamePrefix_ = OutputFilenamePrefix;
}

void simulation_type::
OutputFilenamePrefix (::std::auto_ptr< OutputFilenamePrefix::type > OutputFilenamePrefix)
{
  this->_xsd_OutputFilenamePrefix_.set (OutputFilenamePrefix);
}


// physiological_type
//

const physiological_type::IntracellularConductivities::container& physiological_type::
IntracellularConductivities () const
{
  return this->_xsd_IntracellularConductivities_;
}

physiological_type::IntracellularConductivities::container& physiological_type::
IntracellularConductivities ()
{
  return this->_xsd_IntracellularConductivities_;
}

void physiological_type::
IntracellularConductivities (const IntracellularConductivities::type& IntracellularConductivities)
{
  this->_xsd_IntracellularConductivities_.set (IntracellularConductivities);
}

void physiological_type::
IntracellularConductivities (const IntracellularConductivities::container& IntracellularConductivities)
{
  this->_xsd_IntracellularConductivities_ = IntracellularConductivities;
}

void physiological_type::
IntracellularConductivities (::std::auto_ptr< IntracellularConductivities::type > IntracellularConductivities)
{
  this->_xsd_IntracellularConductivities_.set (IntracellularConductivities);
}

const physiological_type::ExtracellularConductivities::container& physiological_type::
ExtracellularConductivities () const
{
  return this->_xsd_ExtracellularConductivities_;
}

physiological_type::ExtracellularConductivities::container& physiological_type::
ExtracellularConductivities ()
{
  return this->_xsd_ExtracellularConductivities_;
}

void physiological_type::
ExtracellularConductivities (const ExtracellularConductivities::type& ExtracellularConductivities)
{
  this->_xsd_ExtracellularConductivities_.set (ExtracellularConductivities);
}

void physiological_type::
ExtracellularConductivities (const ExtracellularConductivities::container& ExtracellularConductivities)
{
  this->_xsd_ExtracellularConductivities_ = ExtracellularConductivities;
}

void physiological_type::
ExtracellularConductivities (::std::auto_ptr< ExtracellularConductivities::type > ExtracellularConductivities)
{
  this->_xsd_ExtracellularConductivities_.set (ExtracellularConductivities);
}

const physiological_type::BathConductivity::container& physiological_type::
BathConductivity () const
{
  return this->_xsd_BathConductivity_;
}

physiological_type::BathConductivity::container& physiological_type::
BathConductivity ()
{
  return this->_xsd_BathConductivity_;
}

void physiological_type::
BathConductivity (const BathConductivity::type& BathConductivity)
{
  this->_xsd_BathConductivity_.set (BathConductivity);
}

void physiological_type::
BathConductivity (const BathConductivity::container& BathConductivity)
{
  this->_xsd_BathConductivity_ = BathConductivity;
}

void physiological_type::
BathConductivity (::std::auto_ptr< BathConductivity::type > BathConductivity)
{
  this->_xsd_BathConductivity_.set (BathConductivity);
}

const physiological_type::SurfaceAreaToVolumeRatio::container& physiological_type::
SurfaceAreaToVolumeRatio () const
{
  return this->_xsd_SurfaceAreaToVolumeRatio_;
}

physiological_type::SurfaceAreaToVolumeRatio::container& physiological_type::
SurfaceAreaToVolumeRatio ()
{
  return this->_xsd_SurfaceAreaToVolumeRatio_;
}

void physiological_type::
SurfaceAreaToVolumeRatio (const SurfaceAreaToVolumeRatio::type& SurfaceAreaToVolumeRatio)
{
  this->_xsd_SurfaceAreaToVolumeRatio_.set (SurfaceAreaToVolumeRatio);
}

void physiological_type::
SurfaceAreaToVolumeRatio (const SurfaceAreaToVolumeRatio::container& SurfaceAreaToVolumeRatio)
{
  this->_xsd_SurfaceAreaToVolumeRatio_ = SurfaceAreaToVolumeRatio;
}

void physiological_type::
SurfaceAreaToVolumeRatio (::std::auto_ptr< SurfaceAreaToVolumeRatio::type > SurfaceAreaToVolumeRatio)
{
  this->_xsd_SurfaceAreaToVolumeRatio_.set (SurfaceAreaToVolumeRatio);
}

const physiological_type::Capacitance::container& physiological_type::
Capacitance () const
{
  return this->_xsd_Capacitance_;
}

physiological_type::Capacitance::container& physiological_type::
Capacitance ()
{
  return this->_xsd_Capacitance_;
}

void physiological_type::
Capacitance (const Capacitance::type& Capacitance)
{
  this->_xsd_Capacitance_.set (Capacitance);
}

void physiological_type::
Capacitance (const Capacitance::container& Capacitance)
{
  this->_xsd_Capacitance_ = Capacitance;
}

void physiological_type::
Capacitance (::std::auto_ptr< Capacitance::type > Capacitance)
{
  this->_xsd_Capacitance_.set (Capacitance);
}


// numerical_type
//

const numerical_type::TimeSteps::container& numerical_type::
TimeSteps () const
{
  return this->_xsd_TimeSteps_;
}

numerical_type::TimeSteps::container& numerical_type::
TimeSteps ()
{
  return this->_xsd_TimeSteps_;
}

void numerical_type::
TimeSteps (const TimeSteps::type& TimeSteps)
{
  this->_xsd_TimeSteps_.set (TimeSteps);
}

void numerical_type::
TimeSteps (const TimeSteps::container& TimeSteps)
{
  this->_xsd_TimeSteps_ = TimeSteps;
}

void numerical_type::
TimeSteps (::std::auto_ptr< TimeSteps::type > TimeSteps)
{
  this->_xsd_TimeSteps_.set (TimeSteps);
}

const numerical_type::KSPTolerances::container& numerical_type::
KSPTolerances () const
{
  return this->_xsd_KSPTolerances_;
}

numerical_type::KSPTolerances::container& numerical_type::
KSPTolerances ()
{
  return this->_xsd_KSPTolerances_;
}

void numerical_type::
KSPTolerances (const KSPTolerances::type& KSPTolerances)
{
  this->_xsd_KSPTolerances_.set (KSPTolerances);
}

void numerical_type::
KSPTolerances (const KSPTolerances::container& KSPTolerances)
{
  this->_xsd_KSPTolerances_ = KSPTolerances;
}

void numerical_type::
KSPTolerances (::std::auto_ptr< KSPTolerances::type > KSPTolerances)
{
  this->_xsd_KSPTolerances_.set (KSPTolerances);
}

const numerical_type::KSPSolver::container& numerical_type::
KSPSolver () const
{
  return this->_xsd_KSPSolver_;
}

numerical_type::KSPSolver::container& numerical_type::
KSPSolver ()
{
  return this->_xsd_KSPSolver_;
}

void numerical_type::
KSPSolver (const KSPSolver::type& KSPSolver)
{
  this->_xsd_KSPSolver_.set (KSPSolver);
}

void numerical_type::
KSPSolver (const KSPSolver::container& KSPSolver)
{
  this->_xsd_KSPSolver_ = KSPSolver;
}

void numerical_type::
KSPSolver (::std::auto_ptr< KSPSolver::type > KSPSolver)
{
  this->_xsd_KSPSolver_.set (KSPSolver);
}

const numerical_type::KSPPreconditioner::container& numerical_type::
KSPPreconditioner () const
{
  return this->_xsd_KSPPreconditioner_;
}

numerical_type::KSPPreconditioner::container& numerical_type::
KSPPreconditioner ()
{
  return this->_xsd_KSPPreconditioner_;
}

void numerical_type::
KSPPreconditioner (const KSPPreconditioner::type& KSPPreconditioner)
{
  this->_xsd_KSPPreconditioner_.set (KSPPreconditioner);
}

void numerical_type::
KSPPreconditioner (const KSPPreconditioner::container& KSPPreconditioner)
{
  this->_xsd_KSPPreconditioner_ = KSPPreconditioner;
}

void numerical_type::
KSPPreconditioner (::std::auto_ptr< KSPPreconditioner::type > KSPPreconditioner)
{
  this->_xsd_KSPPreconditioner_.set (KSPPreconditioner);
}


// chaste_parameters_type
//

const chaste_parameters_type::Simulation::type& chaste_parameters_type::
Simulation () const
{
  return this->_xsd_Simulation_.get ();
}

chaste_parameters_type::Simulation::type& chaste_parameters_type::
Simulation ()
{
  return this->_xsd_Simulation_.get ();
}

void chaste_parameters_type::
Simulation (const Simulation::type& Simulation)
{
  this->_xsd_Simulation_.set (Simulation);
}

void chaste_parameters_type::
Simulation (::std::auto_ptr< Simulation::type > Simulation)
{
  this->_xsd_Simulation_.set (Simulation);
}

const chaste_parameters_type::Physiological::type& chaste_parameters_type::
Physiological () const
{
  return this->_xsd_Physiological_.get ();
}

chaste_parameters_type::Physiological::type& chaste_parameters_type::
Physiological ()
{
  return this->_xsd_Physiological_.get ();
}

void chaste_parameters_type::
Physiological (const Physiological::type& Physiological)
{
  this->_xsd_Physiological_.set (Physiological);
}

void chaste_parameters_type::
Physiological (::std::auto_ptr< Physiological::type > Physiological)
{
  this->_xsd_Physiological_.set (Physiological);
}

const chaste_parameters_type::Numerical::type& chaste_parameters_type::
Numerical () const
{
  return this->_xsd_Numerical_.get ();
}

chaste_parameters_type::Numerical::type& chaste_parameters_type::
Numerical ()
{
  return this->_xsd_Numerical_.get ();
}

void chaste_parameters_type::
Numerical (const Numerical::type& Numerical)
{
  this->_xsd_Numerical_.set (Numerical);
}

void chaste_parameters_type::
Numerical (::std::auto_ptr< Numerical::type > Numerical)
{
  this->_xsd_Numerical_.set (Numerical);
}


#include <xsd/cxx/xml/dom/elements.hxx>
#include <xsd/cxx/xml/dom/parser.hxx>

// time_type
//

// time_type::unit
//

const time_type::unit::type time_type::unit::default_value_ (
  ::std::basic_string< char > ("ms"), 0, 0, 0);

time_type::
time_type (const _xsd_time_type::base_& _xsd_time_type,
           const unit::type& _xsd_unit)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type > (_xsd_time_type),
_xsd_unit_ (_xsd_unit,
            ::xml_schema::flags (),
            this)
{
}

time_type::
time_type (const time_type& _xsd_time_type,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type > (_xsd_time_type, f, c),
_xsd_unit_ (_xsd_time_type._xsd_unit_,
            f | ::xml_schema::flags::not_root,
            this)
{
}

time_type::
time_type (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type > (e, f, c),
_xsd_unit_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void time_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "unit" && a.namespace_ ().empty ())
    {
      ::std::auto_ptr< unit::type > r (
        unit::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));

      this->unit (r);
      continue;
    }
  }

  if (!_xsd_unit_.present ())
  {
    this->unit (
      unit::traits::create (
        ::std::basic_string< char > ("ms"),
        &e,
        f | ::xml_schema::flags::not_root,
        this));
  }
}

time_type* time_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new time_type (*this, f, c);
}

// dimensionless_type
//

// dimensionless_type::unit
//

const dimensionless_type::unit::type dimensionless_type::unit::default_value_ (
  ::std::basic_string< char > ("dimensionless"), 0, 0, 0);

dimensionless_type::
dimensionless_type (const _xsd_dimensionless_type::base_& _xsd_dimensionless_type,
                    const unit::type& _xsd_unit)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type > (_xsd_dimensionless_type),
_xsd_unit_ (_xsd_unit,
            ::xml_schema::flags (),
            this)
{
}

dimensionless_type::
dimensionless_type (const dimensionless_type& _xsd_dimensionless_type,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type > (_xsd_dimensionless_type, f, c),
_xsd_unit_ (_xsd_dimensionless_type._xsd_unit_,
            f | ::xml_schema::flags::not_root,
            this)
{
}

dimensionless_type::
dimensionless_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type > (e, f, c),
_xsd_unit_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void dimensionless_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "unit" && a.namespace_ ().empty ())
    {
      ::std::auto_ptr< unit::type > r (
        unit::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));

      this->unit (r);
      continue;
    }
  }

  if (!_xsd_unit_.present ())
  {
    this->unit (
      unit::traits::create (
        ::std::basic_string< char > ("dimensionless"),
        &e,
        f | ::xml_schema::flags::not_root,
        this));
  }
}

dimensionless_type* dimensionless_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new dimensionless_type (*this, f, c);
}

// conductivity_type
//

// conductivity_type::unit
//

const conductivity_type::unit::type conductivity_type::unit::default_value_ (
  ::std::basic_string< char > ("mS/cm"), 0, 0, 0);

conductivity_type::
conductivity_type (const _xsd_conductivity_type::base_& _xsd_conductivity_type,
                   const unit::type& _xsd_unit)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type > (_xsd_conductivity_type),
_xsd_unit_ (_xsd_unit,
            ::xml_schema::flags (),
            this)
{
}

conductivity_type::
conductivity_type (const conductivity_type& _xsd_conductivity_type,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type > (_xsd_conductivity_type, f, c),
_xsd_unit_ (_xsd_conductivity_type._xsd_unit_,
            f | ::xml_schema::flags::not_root,
            this)
{
}

conductivity_type::
conductivity_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type > (e, f, c),
_xsd_unit_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void conductivity_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "unit" && a.namespace_ ().empty ())
    {
      ::std::auto_ptr< unit::type > r (
        unit::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));

      this->unit (r);
      continue;
    }
  }

  if (!_xsd_unit_.present ())
  {
    this->unit (
      unit::traits::create (
        ::std::basic_string< char > ("mS/cm"),
        &e,
        f | ::xml_schema::flags::not_root,
        this));
  }
}

conductivity_type* conductivity_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new conductivity_type (*this, f, c);
}

// stimulus_strength_type
//

// stimulus_strength_type::unit
//

const stimulus_strength_type::unit::type stimulus_strength_type::unit::default_value_ (
  ::std::basic_string< char > ("uA/cm^3"), 0, 0, 0);

stimulus_strength_type::
stimulus_strength_type (const _xsd_stimulus_strength_type::base_& _xsd_stimulus_strength_type,
                        const unit::type& _xsd_unit)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type > (_xsd_stimulus_strength_type),
_xsd_unit_ (_xsd_unit,
            ::xml_schema::flags (),
            this)
{
}

stimulus_strength_type::
stimulus_strength_type (const stimulus_strength_type& _xsd_stimulus_strength_type,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type > (_xsd_stimulus_strength_type, f, c),
_xsd_unit_ (_xsd_stimulus_strength_type._xsd_unit_,
            f | ::xml_schema::flags::not_root,
            this)
{
}

stimulus_strength_type::
stimulus_strength_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type > (e, f, c),
_xsd_unit_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void stimulus_strength_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "unit" && a.namespace_ ().empty ())
    {
      ::std::auto_ptr< unit::type > r (
        unit::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));

      this->unit (r);
      continue;
    }
  }

  if (!_xsd_unit_.present ())
  {
    this->unit (
      unit::traits::create (
        ::std::basic_string< char > ("uA/cm^3"),
        &e,
        f | ::xml_schema::flags::not_root,
        this));
  }
}

stimulus_strength_type* stimulus_strength_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new stimulus_strength_type (*this, f, c);
}

// inverse_length_type
//

// inverse_length_type::unit
//

const inverse_length_type::unit::type inverse_length_type::unit::default_value_ (
  ::std::basic_string< char > ("1/cm"), 0, 0, 0);

inverse_length_type::
inverse_length_type (const _xsd_inverse_length_type::base_& _xsd_inverse_length_type,
                     const unit::type& _xsd_unit)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type > (_xsd_inverse_length_type),
_xsd_unit_ (_xsd_unit,
            ::xml_schema::flags (),
            this)
{
}

inverse_length_type::
inverse_length_type (const inverse_length_type& _xsd_inverse_length_type,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type > (_xsd_inverse_length_type, f, c),
_xsd_unit_ (_xsd_inverse_length_type._xsd_unit_,
            f | ::xml_schema::flags::not_root,
            this)
{
}

inverse_length_type::
inverse_length_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type > (e, f, c),
_xsd_unit_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void inverse_length_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "unit" && a.namespace_ ().empty ())
    {
      ::std::auto_ptr< unit::type > r (
        unit::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));

      this->unit (r);
      continue;
    }
  }

  if (!_xsd_unit_.present ())
  {
    this->unit (
      unit::traits::create (
        ::std::basic_string< char > ("1/cm"),
        &e,
        f | ::xml_schema::flags::not_root,
        this));
  }
}

inverse_length_type* inverse_length_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new inverse_length_type (*this, f, c);
}

// capacitance_type
//

// capacitance_type::unit
//

const capacitance_type::unit::type capacitance_type::unit::default_value_ (
  ::std::basic_string< char > ("uF/cm^2"), 0, 0, 0);

capacitance_type::
capacitance_type (const _xsd_capacitance_type::base_& _xsd_capacitance_type,
                  const unit::type& _xsd_unit)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type > (_xsd_capacitance_type),
_xsd_unit_ (_xsd_unit,
            ::xml_schema::flags (),
            this)
{
}

capacitance_type::
capacitance_type (const capacitance_type& _xsd_capacitance_type,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type > (_xsd_capacitance_type, f, c),
_xsd_unit_ (_xsd_capacitance_type._xsd_unit_,
            f | ::xml_schema::flags::not_root,
            this)
{
}

capacitance_type::
capacitance_type (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type > (e, f, c),
_xsd_unit_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void capacitance_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "unit" && a.namespace_ ().empty ())
    {
      ::std::auto_ptr< unit::type > r (
        unit::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));

      this->unit (r);
      continue;
    }
  }

  if (!_xsd_unit_.present ())
  {
    this->unit (
      unit::traits::create (
        ::std::basic_string< char > ("uF/cm^2"),
        &e,
        f | ::xml_schema::flags::not_root,
        this));
  }
}

capacitance_type* capacitance_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new capacitance_type (*this, f, c);
}

// location_type
//

// location_type::unit
//

const location_type::unit::type location_type::unit::default_value_ (
  ::std::basic_string< char > ("cm"), 0, 0, 0);

location_type::
location_type (const Cuboid::type& _xsd_Cuboid,
               const unit::type& _xsd_unit)
: ::xml_schema::type (),
_xsd_Cuboid_ (_xsd_Cuboid,
              ::xml_schema::flags (),
              this),
_xsd_unit_ (_xsd_unit,
            ::xml_schema::flags (),
            this)
{
}

location_type::
location_type (const location_type& _xsd_location_type,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
: ::xml_schema::type (_xsd_location_type, f, c),
_xsd_Cuboid_ (_xsd_location_type._xsd_Cuboid_,
              f | ::xml_schema::flags::not_root,
              this),
_xsd_unit_ (_xsd_location_type._xsd_unit_,
            f | ::xml_schema::flags::not_root,
            this)
{
}

location_type::
location_type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_Cuboid_ (f | ::xml_schema::flags::not_root, this),
_xsd_unit_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void location_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // Cuboid
    //
    {
      if (e.name () == "Cuboid" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< Cuboid::type > r (
          Cuboid::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_Cuboid_.present ())
          continue;
        this->Cuboid (r);
        continue;
      }
    }
  }

  if (!_xsd_Cuboid_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Cuboid",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "unit" && a.namespace_ ().empty ())
    {
      ::std::auto_ptr< unit::type > r (
        unit::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));

      this->unit (r);
      continue;
    }
  }

  if (!_xsd_unit_.present ())
  {
    this->unit (
      unit::traits::create (
        ::std::basic_string< char > ("cm"),
        &e,
        f | ::xml_schema::flags::not_root,
        this));
  }
}

location_type* location_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new location_type (*this, f, c);
}

// domain_type
//

domain_type::
domain_type (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_domain_type_convert ();
}

domain_type::
domain_type (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_domain_type_convert ();
}

domain_type::
domain_type (const ::std::basic_string< char >& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_domain_type_convert ();
}

domain_type* domain_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new domain_type (*this, f, c);
}

domain_type::_xsd_domain_type domain_type::
_xsd_domain_type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_domain_type_literals_);
  const _xsd_domain_type* i (::std::lower_bound (
                               _xsd_domain_type_indexes_,
                               _xsd_domain_type_indexes_ + 2,
                               *this,
                               c));

  if (i == _xsd_domain_type_indexes_ + 2 || _xsd_domain_type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const domain_type::
_xsd_domain_type_literals_[2] =
{
  "Mono",
  "Bi"
};

const domain_type::_xsd_domain_type domain_type::
_xsd_domain_type_indexes_[2] =
{
  ::domain_type::Bi,
  ::domain_type::Mono
};

// ionic_models_available_type
//

ionic_models_available_type::
ionic_models_available_type (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_ionic_models_available_type_convert ();
}

ionic_models_available_type::
ionic_models_available_type (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_ionic_models_available_type_convert ();
}

ionic_models_available_type::
ionic_models_available_type (const ::std::basic_string< char >& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_ionic_models_available_type_convert ();
}

ionic_models_available_type* ionic_models_available_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new ionic_models_available_type (*this, f, c);
}

ionic_models_available_type::_xsd_ionic_models_available_type ionic_models_available_type::
_xsd_ionic_models_available_type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ionic_models_available_type_literals_);
  const _xsd_ionic_models_available_type* i (::std::lower_bound (
                                               _xsd_ionic_models_available_type_indexes_,
                                               _xsd_ionic_models_available_type_indexes_ + 9,
                                               *this,
                                               c));

  if (i == _xsd_ionic_models_available_type_indexes_ + 9 || _xsd_ionic_models_available_type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ionic_models_available_type::
_xsd_ionic_models_available_type_literals_[9] =
{
  "Fox2002BackwardEuler",
  "LuoRudyIBackwardEuler",
  "LuoRudyI",
  "FaberRudy2000Optimised",
  "FaberRudy2000",
  "DifrancescoNoble",
  "MahajanShiferaw",
  "HodgkinHuxley",
  "tenTusscher2006"
};

const ionic_models_available_type::_xsd_ionic_models_available_type ionic_models_available_type::
_xsd_ionic_models_available_type_indexes_[9] =
{
  ::ionic_models_available_type::DifrancescoNoble,
  ::ionic_models_available_type::FaberRudy2000,
  ::ionic_models_available_type::FaberRudy2000Optimised,
  ::ionic_models_available_type::Fox2002BackwardEuler,
  ::ionic_models_available_type::HodgkinHuxley,
  ::ionic_models_available_type::LuoRudyI,
  ::ionic_models_available_type::LuoRudyIBackwardEuler,
  ::ionic_models_available_type::MahajanShiferaw,
  ::ionic_models_available_type::tenTusscher2006
};

// ionic_model_region_type
//

ionic_model_region_type::
ionic_model_region_type (const IonicModel::type& _xsd_IonicModel,
                         const Location::type& _xsd_Location)
: ::xml_schema::type (),
_xsd_IonicModel_ (_xsd_IonicModel,
                  ::xml_schema::flags (),
                  this),
_xsd_Location_ (_xsd_Location,
                ::xml_schema::flags (),
                this)
{
}

ionic_model_region_type::
ionic_model_region_type (const ionic_model_region_type& _xsd_ionic_model_region_type,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
: ::xml_schema::type (_xsd_ionic_model_region_type, f, c),
_xsd_IonicModel_ (_xsd_ionic_model_region_type._xsd_IonicModel_,
                  f | ::xml_schema::flags::not_root,
                  this),
_xsd_Location_ (_xsd_ionic_model_region_type._xsd_Location_,
                f | ::xml_schema::flags::not_root,
                this)
{
}

ionic_model_region_type::
ionic_model_region_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_IonicModel_ (f | ::xml_schema::flags::not_root, this),
_xsd_Location_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void ionic_model_region_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // IonicModel
    //
    {
      if (e.name () == "IonicModel" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< IonicModel::type > r (
          IonicModel::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_IonicModel_.present ())
          continue;
        this->IonicModel (r);
        continue;
      }
    }

    // Location
    //
    {
      if (e.name () == "Location" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< Location::type > r (
          Location::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_Location_.present ())
          continue;
        this->Location (r);
        continue;
      }
    }
  }

  if (!_xsd_IonicModel_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "IonicModel",
      "");
  }

  if (!_xsd_Location_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Location",
      "");
  }
}

ionic_model_region_type* ionic_model_region_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new ionic_model_region_type (*this, f, c);
}

// ionic_models_type
//

ionic_models_type::
ionic_models_type (const Default::type& _xsd_Default)
: ::xml_schema::type (),
_xsd_Default_ (_xsd_Default,
               ::xml_schema::flags (),
               this),
_xsd_Region_ (::xml_schema::flags (), this)
{
}

ionic_models_type::
ionic_models_type (const ionic_models_type& _xsd_ionic_models_type,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
: ::xml_schema::type (_xsd_ionic_models_type, f, c),
_xsd_Default_ (_xsd_ionic_models_type._xsd_Default_,
               f | ::xml_schema::flags::not_root,
               this),
_xsd_Region_ (_xsd_ionic_models_type._xsd_Region_,
              f | ::xml_schema::flags::not_root,
              this)
{
}

ionic_models_type::
ionic_models_type (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_Default_ (f | ::xml_schema::flags::not_root, this),
_xsd_Region_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void ionic_models_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // Default
    //
    {
      if (e.name () == "Default" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< Default::type > r (
          Default::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_Default_.present ())
          continue;
        this->Default (r);
        continue;
      }
    }

    // Region
    //
    {
      if (e.name () == "Region" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< Region::type > r (
          Region::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        this->Region ().push_back (r);
        continue;
      }
    }
  }

  if (!_xsd_Default_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Default",
      "");
  }
}

ionic_models_type* ionic_models_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new ionic_models_type (*this, f, c);
}

// media_type
//

media_type::
media_type (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_media_type_convert ();
}

media_type::
media_type (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_media_type_convert ();
}

media_type::
media_type (const ::std::basic_string< char >& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_media_type_convert ();
}

media_type* media_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new media_type (*this, f, c);
}

media_type::_xsd_media_type media_type::
_xsd_media_type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_media_type_literals_);
  const _xsd_media_type* i (::std::lower_bound (
                              _xsd_media_type_indexes_,
                              _xsd_media_type_indexes_ + 3,
                              *this,
                              c));

  if (i == _xsd_media_type_indexes_ + 3 || _xsd_media_type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const media_type::
_xsd_media_type_literals_[3] =
{
  "Orthotropic",
  "Axisymmetric",
  "NoFibreOrientation"
};

const media_type::_xsd_media_type media_type::
_xsd_media_type_indexes_[3] =
{
  ::media_type::Axisymmetric,
  ::media_type::NoFibreOrientation,
  ::media_type::Orthotropic
};

// point_type
//

point_type::
point_type (const x::type& _xsd_x,
            const y::type& _xsd_y,
            const z::type& _xsd_z)
: ::xml_schema::type (),
_xsd_x_ (_xsd_x,
         ::xml_schema::flags (),
         this),
_xsd_y_ (_xsd_y,
         ::xml_schema::flags (),
         this),
_xsd_z_ (_xsd_z,
         ::xml_schema::flags (),
         this)
{
}

point_type::
point_type (const point_type& _xsd_point_type,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::type (_xsd_point_type, f, c),
_xsd_x_ (_xsd_point_type._xsd_x_,
         f | ::xml_schema::flags::not_root,
         this),
_xsd_y_ (_xsd_point_type._xsd_y_,
         f | ::xml_schema::flags::not_root,
         this),
_xsd_z_ (_xsd_point_type._xsd_z_,
         f | ::xml_schema::flags::not_root,
         this)
{
}

point_type::
point_type (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_x_ (f | ::xml_schema::flags::not_root, this),
_xsd_y_ (f | ::xml_schema::flags::not_root, this),
_xsd_z_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void point_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "x" && a.namespace_ ().empty ())
    {
      this->x (
        x::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }

    if (a.name () == "y" && a.namespace_ ().empty ())
    {
      this->y (
        y::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }

    if (a.name () == "z" && a.namespace_ ().empty ())
    {
      this->z (
        z::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }
  }

  if (!_xsd_x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!_xsd_y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }

  if (!_xsd_z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "z",
      "");
  }
}

point_type* point_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new point_type (*this, f, c);
}

// box_type
//

box_type::
box_type (const LowerCoordinates::type& _xsd_LowerCoordinates,
          const UpperCoordinates::type& _xsd_UpperCoordinates)
: ::xml_schema::type (),
_xsd_LowerCoordinates_ (_xsd_LowerCoordinates,
                        ::xml_schema::flags (),
                        this),
_xsd_UpperCoordinates_ (_xsd_UpperCoordinates,
                        ::xml_schema::flags (),
                        this)
{
}

box_type::
box_type (const box_type& _xsd_box_type,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
: ::xml_schema::type (_xsd_box_type, f, c),
_xsd_LowerCoordinates_ (_xsd_box_type._xsd_LowerCoordinates_,
                        f | ::xml_schema::flags::not_root,
                        this),
_xsd_UpperCoordinates_ (_xsd_box_type._xsd_UpperCoordinates_,
                        f | ::xml_schema::flags::not_root,
                        this)
{
}

box_type::
box_type (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_LowerCoordinates_ (f | ::xml_schema::flags::not_root, this),
_xsd_UpperCoordinates_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void box_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // LowerCoordinates
    //
    {
      if (e.name () == "LowerCoordinates" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< LowerCoordinates::type > r (
          LowerCoordinates::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_LowerCoordinates_.present ())
          continue;
        this->LowerCoordinates (r);
        continue;
      }
    }

    // UpperCoordinates
    //
    {
      if (e.name () == "UpperCoordinates" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< UpperCoordinates::type > r (
          UpperCoordinates::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_UpperCoordinates_.present ())
          continue;
        this->UpperCoordinates (r);
        continue;
      }
    }
  }

  if (!_xsd_LowerCoordinates_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "LowerCoordinates",
      "");
  }

  if (!_xsd_UpperCoordinates_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "UpperCoordinates",
      "");
  }
}

box_type* box_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new box_type (*this, f, c);
}

// stimulus_type
//

stimulus_type::
stimulus_type (const Strength::type& _xsd_Strength,
               const Duration::type& _xsd_Duration,
               const Delay::type& _xsd_Delay,
               const Location::type& _xsd_Location)
: ::xml_schema::type (),
_xsd_Strength_ (_xsd_Strength,
                ::xml_schema::flags (),
                this),
_xsd_Duration_ (_xsd_Duration,
                ::xml_schema::flags (),
                this),
_xsd_Delay_ (_xsd_Delay,
             ::xml_schema::flags (),
             this),
_xsd_Location_ (_xsd_Location,
                ::xml_schema::flags (),
                this)
{
}

stimulus_type::
stimulus_type (const stimulus_type& _xsd_stimulus_type,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
: ::xml_schema::type (_xsd_stimulus_type, f, c),
_xsd_Strength_ (_xsd_stimulus_type._xsd_Strength_,
                f | ::xml_schema::flags::not_root,
                this),
_xsd_Duration_ (_xsd_stimulus_type._xsd_Duration_,
                f | ::xml_schema::flags::not_root,
                this),
_xsd_Delay_ (_xsd_stimulus_type._xsd_Delay_,
             f | ::xml_schema::flags::not_root,
             this),
_xsd_Location_ (_xsd_stimulus_type._xsd_Location_,
                f | ::xml_schema::flags::not_root,
                this)
{
}

stimulus_type::
stimulus_type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_Strength_ (f | ::xml_schema::flags::not_root, this),
_xsd_Duration_ (f | ::xml_schema::flags::not_root, this),
_xsd_Delay_ (f | ::xml_schema::flags::not_root, this),
_xsd_Location_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void stimulus_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // Strength
    //
    {
      if (e.name () == "Strength" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< Strength::type > r (
          Strength::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_Strength_.present ())
          continue;
        this->Strength (r);
        continue;
      }
    }

    // Duration
    //
    {
      if (e.name () == "Duration" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< Duration::type > r (
          Duration::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_Duration_.present ())
          continue;
        this->Duration (r);
        continue;
      }
    }

    // Delay
    //
    {
      if (e.name () == "Delay" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< Delay::type > r (
          Delay::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_Delay_.present ())
          continue;
        this->Delay (r);
        continue;
      }
    }

    // Location
    //
    {
      if (e.name () == "Location" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< Location::type > r (
          Location::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_Location_.present ())
          continue;
        this->Location (r);
        continue;
      }
    }
  }

  if (!_xsd_Strength_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Strength",
      "");
  }

  if (!_xsd_Duration_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Duration",
      "");
  }

  if (!_xsd_Delay_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Delay",
      "");
  }

  if (!_xsd_Location_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Location",
      "");
  }
}

stimulus_type* stimulus_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new stimulus_type (*this, f, c);
}

// cell_heterogeneity_type
//

cell_heterogeneity_type::
cell_heterogeneity_type (const ScaleFactorGks::type& _xsd_ScaleFactorGks,
                         const ScaleFactorIto::type& _xsd_ScaleFactorIto,
                         const ScaleFactorGkr::type& _xsd_ScaleFactorGkr,
                         const Location::type& _xsd_Location)
: ::xml_schema::type (),
_xsd_ScaleFactorGks_ (_xsd_ScaleFactorGks,
                      ::xml_schema::flags (),
                      this),
_xsd_ScaleFactorIto_ (_xsd_ScaleFactorIto,
                      ::xml_schema::flags (),
                      this),
_xsd_ScaleFactorGkr_ (_xsd_ScaleFactorGkr,
                      ::xml_schema::flags (),
                      this),
_xsd_Location_ (_xsd_Location,
                ::xml_schema::flags (),
                this)
{
}

cell_heterogeneity_type::
cell_heterogeneity_type (const cell_heterogeneity_type& _xsd_cell_heterogeneity_type,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
: ::xml_schema::type (_xsd_cell_heterogeneity_type, f, c),
_xsd_ScaleFactorGks_ (_xsd_cell_heterogeneity_type._xsd_ScaleFactorGks_,
                      f | ::xml_schema::flags::not_root,
                      this),
_xsd_ScaleFactorIto_ (_xsd_cell_heterogeneity_type._xsd_ScaleFactorIto_,
                      f | ::xml_schema::flags::not_root,
                      this),
_xsd_ScaleFactorGkr_ (_xsd_cell_heterogeneity_type._xsd_ScaleFactorGkr_,
                      f | ::xml_schema::flags::not_root,
                      this),
_xsd_Location_ (_xsd_cell_heterogeneity_type._xsd_Location_,
                f | ::xml_schema::flags::not_root,
                this)
{
}

cell_heterogeneity_type::
cell_heterogeneity_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_ScaleFactorGks_ (f | ::xml_schema::flags::not_root, this),
_xsd_ScaleFactorIto_ (f | ::xml_schema::flags::not_root, this),
_xsd_ScaleFactorGkr_ (f | ::xml_schema::flags::not_root, this),
_xsd_Location_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void cell_heterogeneity_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // ScaleFactorGks
    //
    {
      if (e.name () == "ScaleFactorGks" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< ScaleFactorGks::type > r (
          ScaleFactorGks::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_ScaleFactorGks_.present ())
          continue;
        this->ScaleFactorGks (r);
        continue;
      }
    }

    // ScaleFactorIto
    //
    {
      if (e.name () == "ScaleFactorIto" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< ScaleFactorIto::type > r (
          ScaleFactorIto::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_ScaleFactorIto_.present ())
          continue;
        this->ScaleFactorIto (r);
        continue;
      }
    }

    // ScaleFactorGkr
    //
    {
      if (e.name () == "ScaleFactorGkr" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< ScaleFactorGkr::type > r (
          ScaleFactorGkr::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_ScaleFactorGkr_.present ())
          continue;
        this->ScaleFactorGkr (r);
        continue;
      }
    }

    // Location
    //
    {
      if (e.name () == "Location" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< Location::type > r (
          Location::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_Location_.present ())
          continue;
        this->Location (r);
        continue;
      }
    }
  }

  if (!_xsd_ScaleFactorGks_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ScaleFactorGks",
      "");
  }

  if (!_xsd_ScaleFactorIto_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ScaleFactorIto",
      "");
  }

  if (!_xsd_ScaleFactorGkr_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ScaleFactorGkr",
      "");
  }

  if (!_xsd_Location_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Location",
      "");
  }
}

cell_heterogeneity_type* cell_heterogeneity_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new cell_heterogeneity_type (*this, f, c);
}

// conductivity_heterogeneity_type
//

conductivity_heterogeneity_type::
conductivity_heterogeneity_type (const Location::type& _xsd_Location)
: ::xml_schema::type (),
_xsd_IntracellularConductivities_ (::xml_schema::flags (), this),
_xsd_ExtracellularConductivities_ (::xml_schema::flags (), this),
_xsd_Location_ (_xsd_Location,
                ::xml_schema::flags (),
                this)
{
}

conductivity_heterogeneity_type::
conductivity_heterogeneity_type (const conductivity_heterogeneity_type& _xsd_conductivity_heterogeneity_type,
                                 ::xml_schema::flags f,
                                 ::xml_schema::type* c)
: ::xml_schema::type (_xsd_conductivity_heterogeneity_type, f, c),
_xsd_IntracellularConductivities_ (_xsd_conductivity_heterogeneity_type._xsd_IntracellularConductivities_,
                                   f | ::xml_schema::flags::not_root,
                                   this),
_xsd_ExtracellularConductivities_ (_xsd_conductivity_heterogeneity_type._xsd_ExtracellularConductivities_,
                                   f | ::xml_schema::flags::not_root,
                                   this),
_xsd_Location_ (_xsd_conductivity_heterogeneity_type._xsd_Location_,
                f | ::xml_schema::flags::not_root,
                this)
{
}

conductivity_heterogeneity_type::
conductivity_heterogeneity_type (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f,
                                 ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_IntracellularConductivities_ (f | ::xml_schema::flags::not_root, this),
_xsd_ExtracellularConductivities_ (f | ::xml_schema::flags::not_root, this),
_xsd_Location_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void conductivity_heterogeneity_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // IntracellularConductivities
    //
    {
      if (e.name () == "IntracellularConductivities" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< IntracellularConductivities::type > r (
          IntracellularConductivities::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->IntracellularConductivities ())
          continue;
        this->IntracellularConductivities (r);
        continue;
      }
    }

    // ExtracellularConductivities
    //
    {
      if (e.name () == "ExtracellularConductivities" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< ExtracellularConductivities::type > r (
          ExtracellularConductivities::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->ExtracellularConductivities ())
          continue;
        this->ExtracellularConductivities (r);
        continue;
      }
    }

    // Location
    //
    {
      if (e.name () == "Location" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< Location::type > r (
          Location::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_Location_.present ())
          continue;
        this->Location (r);
        continue;
      }
    }
  }

  if (!_xsd_Location_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Location",
      "");
  }
}

conductivity_heterogeneity_type* conductivity_heterogeneity_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new conductivity_heterogeneity_type (*this, f, c);
}

// slab_type
//

slab_type::
slab_type (const x::type& _xsd_x,
           const y::type& _xsd_y,
           const z::type& _xsd_z,
           const inter_node_space::type& _xsd_inter_node_space)
: ::xml_schema::type (),
_xsd_x_ (_xsd_x,
         ::xml_schema::flags (),
         this),
_xsd_y_ (_xsd_y,
         ::xml_schema::flags (),
         this),
_xsd_z_ (_xsd_z,
         ::xml_schema::flags (),
         this),
_xsd_inter_node_space_ (_xsd_inter_node_space,
                        ::xml_schema::flags (),
                        this)
{
}

slab_type::
slab_type (const slab_type& _xsd_slab_type,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
: ::xml_schema::type (_xsd_slab_type, f, c),
_xsd_x_ (_xsd_slab_type._xsd_x_,
         f | ::xml_schema::flags::not_root,
         this),
_xsd_y_ (_xsd_slab_type._xsd_y_,
         f | ::xml_schema::flags::not_root,
         this),
_xsd_z_ (_xsd_slab_type._xsd_z_,
         f | ::xml_schema::flags::not_root,
         this),
_xsd_inter_node_space_ (_xsd_slab_type._xsd_inter_node_space_,
                        f | ::xml_schema::flags::not_root,
                        this)
{
}

slab_type::
slab_type (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_x_ (f | ::xml_schema::flags::not_root, this),
_xsd_y_ (f | ::xml_schema::flags::not_root, this),
_xsd_z_ (f | ::xml_schema::flags::not_root, this),
_xsd_inter_node_space_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void slab_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "x" && a.namespace_ ().empty ())
    {
      this->x (
        x::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }

    if (a.name () == "y" && a.namespace_ ().empty ())
    {
      this->y (
        y::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }

    if (a.name () == "z" && a.namespace_ ().empty ())
    {
      this->z (
        z::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }

    if (a.name () == "inter_node_space" && a.namespace_ ().empty ())
    {
      this->inter_node_space (
        inter_node_space::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }
  }

  if (!_xsd_x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!_xsd_y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }

  if (!_xsd_z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "z",
      "");
  }

  if (!_xsd_inter_node_space_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "inter_node_space",
      "");
  }
}

slab_type* slab_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new slab_type (*this, f, c);
}

// sheet_type
//

sheet_type::
sheet_type (const x::type& _xsd_x,
            const y::type& _xsd_y,
            const inter_node_space::type& _xsd_inter_node_space)
: ::xml_schema::type (),
_xsd_x_ (_xsd_x,
         ::xml_schema::flags (),
         this),
_xsd_y_ (_xsd_y,
         ::xml_schema::flags (),
         this),
_xsd_inter_node_space_ (_xsd_inter_node_space,
                        ::xml_schema::flags (),
                        this)
{
}

sheet_type::
sheet_type (const sheet_type& _xsd_sheet_type,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::type (_xsd_sheet_type, f, c),
_xsd_x_ (_xsd_sheet_type._xsd_x_,
         f | ::xml_schema::flags::not_root,
         this),
_xsd_y_ (_xsd_sheet_type._xsd_y_,
         f | ::xml_schema::flags::not_root,
         this),
_xsd_inter_node_space_ (_xsd_sheet_type._xsd_inter_node_space_,
                        f | ::xml_schema::flags::not_root,
                        this)
{
}

sheet_type::
sheet_type (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_x_ (f | ::xml_schema::flags::not_root, this),
_xsd_y_ (f | ::xml_schema::flags::not_root, this),
_xsd_inter_node_space_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void sheet_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "x" && a.namespace_ ().empty ())
    {
      this->x (
        x::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }

    if (a.name () == "y" && a.namespace_ ().empty ())
    {
      this->y (
        y::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }

    if (a.name () == "inter_node_space" && a.namespace_ ().empty ())
    {
      this->inter_node_space (
        inter_node_space::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }
  }

  if (!_xsd_x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!_xsd_y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "y",
      "");
  }

  if (!_xsd_inter_node_space_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "inter_node_space",
      "");
  }
}

sheet_type* sheet_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new sheet_type (*this, f, c);
}

// fibre_type
//

fibre_type::
fibre_type (const x::type& _xsd_x,
            const inter_node_space::type& _xsd_inter_node_space)
: ::xml_schema::type (),
_xsd_x_ (_xsd_x,
         ::xml_schema::flags (),
         this),
_xsd_inter_node_space_ (_xsd_inter_node_space,
                        ::xml_schema::flags (),
                        this)
{
}

fibre_type::
fibre_type (const fibre_type& _xsd_fibre_type,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::type (_xsd_fibre_type, f, c),
_xsd_x_ (_xsd_fibre_type._xsd_x_,
         f | ::xml_schema::flags::not_root,
         this),
_xsd_inter_node_space_ (_xsd_fibre_type._xsd_inter_node_space_,
                        f | ::xml_schema::flags::not_root,
                        this)
{
}

fibre_type::
fibre_type (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_x_ (f | ::xml_schema::flags::not_root, this),
_xsd_inter_node_space_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void fibre_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "x" && a.namespace_ ().empty ())
    {
      this->x (
        x::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }

    if (a.name () == "inter_node_space" && a.namespace_ ().empty ())
    {
      this->inter_node_space (
        inter_node_space::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }
  }

  if (!_xsd_x_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "x",
      "");
  }

  if (!_xsd_inter_node_space_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "inter_node_space",
      "");
  }
}

fibre_type* fibre_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new fibre_type (*this, f, c);
}

// load_mesh_type
//

load_mesh_type::
load_mesh_type (const name::type& _xsd_name,
                const conductivity_media::type& _xsd_conductivity_media)
: ::xml_schema::type (),
_xsd_name_ (_xsd_name,
            ::xml_schema::flags (),
            this),
_xsd_conductivity_media_ (_xsd_conductivity_media,
                          ::xml_schema::flags (),
                          this)
{
}

load_mesh_type::
load_mesh_type (const load_mesh_type& _xsd_load_mesh_type,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
: ::xml_schema::type (_xsd_load_mesh_type, f, c),
_xsd_name_ (_xsd_load_mesh_type._xsd_name_,
            f | ::xml_schema::flags::not_root,
            this),
_xsd_conductivity_media_ (_xsd_load_mesh_type._xsd_conductivity_media_,
                          f | ::xml_schema::flags::not_root,
                          this)
{
}

load_mesh_type::
load_mesh_type (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_name_ (f | ::xml_schema::flags::not_root, this),
_xsd_conductivity_media_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void load_mesh_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "name" && a.namespace_ ().empty ())
    {
      ::std::auto_ptr< name::type > r (
        name::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));

      this->name (r);
      continue;
    }

    if (a.name () == "conductivity_media" && a.namespace_ ().empty ())
    {
      ::std::auto_ptr< conductivity_media::type > r (
        conductivity_media::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));

      this->conductivity_media (r);
      continue;
    }
  }

  if (!_xsd_name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!_xsd_conductivity_media_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "conductivity_media",
      "");
  }
}

load_mesh_type* load_mesh_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new load_mesh_type (*this, f, c);
}

// mesh_type
//

// mesh_type::unit
//

const mesh_type::unit::type mesh_type::unit::default_value_ (
  ::std::basic_string< char > ("cm"), 0, 0, 0);

mesh_type::
mesh_type (const unit::type& _xsd_unit)
: ::xml_schema::type (),
_xsd_Slab_ (::xml_schema::flags (), this),
_xsd_Sheet_ (::xml_schema::flags (), this),
_xsd_Fibre_ (::xml_schema::flags (), this),
_xsd_LoadMesh_ (::xml_schema::flags (), this),
_xsd_unit_ (_xsd_unit,
            ::xml_schema::flags (),
            this)
{
}

mesh_type::
mesh_type (const mesh_type& _xsd_mesh_type,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
: ::xml_schema::type (_xsd_mesh_type, f, c),
_xsd_Slab_ (_xsd_mesh_type._xsd_Slab_,
            f | ::xml_schema::flags::not_root,
            this),
_xsd_Sheet_ (_xsd_mesh_type._xsd_Sheet_,
             f | ::xml_schema::flags::not_root,
             this),
_xsd_Fibre_ (_xsd_mesh_type._xsd_Fibre_,
             f | ::xml_schema::flags::not_root,
             this),
_xsd_LoadMesh_ (_xsd_mesh_type._xsd_LoadMesh_,
                f | ::xml_schema::flags::not_root,
                this),
_xsd_unit_ (_xsd_mesh_type._xsd_unit_,
            f | ::xml_schema::flags::not_root,
            this)
{
}

mesh_type::
mesh_type (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_Slab_ (f | ::xml_schema::flags::not_root, this),
_xsd_Sheet_ (f | ::xml_schema::flags::not_root, this),
_xsd_Fibre_ (f | ::xml_schema::flags::not_root, this),
_xsd_LoadMesh_ (f | ::xml_schema::flags::not_root, this),
_xsd_unit_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void mesh_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // Slab
    //
    {
      if (e.name () == "Slab" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< Slab::type > r (
          Slab::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->Slab ())
          continue;
        this->Slab (r);
        continue;
      }
    }

    // Sheet
    //
    {
      if (e.name () == "Sheet" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< Sheet::type > r (
          Sheet::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->Sheet ())
          continue;
        this->Sheet (r);
        continue;
      }
    }

    // Fibre
    //
    {
      if (e.name () == "Fibre" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< Fibre::type > r (
          Fibre::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->Fibre ())
          continue;
        this->Fibre (r);
        continue;
      }
    }

    // LoadMesh
    //
    {
      if (e.name () == "LoadMesh" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< LoadMesh::type > r (
          LoadMesh::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->LoadMesh ())
          continue;
        this->LoadMesh (r);
        continue;
      }
    }
  }

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "unit" && a.namespace_ ().empty ())
    {
      ::std::auto_ptr< unit::type > r (
        unit::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));

      this->unit (r);
      continue;
    }
  }

  if (!_xsd_unit_.present ())
  {
    this->unit (
      unit::traits::create (
        ::std::basic_string< char > ("cm"),
        &e,
        f | ::xml_schema::flags::not_root,
        this));
  }
}

mesh_type* mesh_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new mesh_type (*this, f, c);
}

// conductivities_type
//

// conductivities_type::unit
//

const conductivities_type::unit::type conductivities_type::unit::default_value_ (
  ::std::basic_string< char > ("mS/cm"), 0, 0, 0);

conductivities_type::
conductivities_type (const longi::type& _xsd_longi,
                     const trans::type& _xsd_trans,
                     const normal::type& _xsd_normal,
                     const unit::type& _xsd_unit)
: ::xml_schema::type (),
_xsd_longi_ (_xsd_longi,
             ::xml_schema::flags (),
             this),
_xsd_trans_ (_xsd_trans,
             ::xml_schema::flags (),
             this),
_xsd_normal_ (_xsd_normal,
              ::xml_schema::flags (),
              this),
_xsd_unit_ (_xsd_unit,
            ::xml_schema::flags (),
            this)
{
}

conductivities_type::
conductivities_type (const conductivities_type& _xsd_conductivities_type,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
: ::xml_schema::type (_xsd_conductivities_type, f, c),
_xsd_longi_ (_xsd_conductivities_type._xsd_longi_,
             f | ::xml_schema::flags::not_root,
             this),
_xsd_trans_ (_xsd_conductivities_type._xsd_trans_,
             f | ::xml_schema::flags::not_root,
             this),
_xsd_normal_ (_xsd_conductivities_type._xsd_normal_,
              f | ::xml_schema::flags::not_root,
              this),
_xsd_unit_ (_xsd_conductivities_type._xsd_unit_,
            f | ::xml_schema::flags::not_root,
            this)
{
}

conductivities_type::
conductivities_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_longi_ (f | ::xml_schema::flags::not_root, this),
_xsd_trans_ (f | ::xml_schema::flags::not_root, this),
_xsd_normal_ (f | ::xml_schema::flags::not_root, this),
_xsd_unit_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void conductivities_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "longi" && a.namespace_ ().empty ())
    {
      this->longi (
        longi::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }

    if (a.name () == "trans" && a.namespace_ ().empty ())
    {
      this->trans (
        trans::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }

    if (a.name () == "normal" && a.namespace_ ().empty ())
    {
      this->normal (
        normal::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }

    if (a.name () == "unit" && a.namespace_ ().empty ())
    {
      ::std::auto_ptr< unit::type > r (
        unit::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));

      this->unit (r);
      continue;
    }
  }

  if (!_xsd_longi_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "longi",
      "");
  }

  if (!_xsd_trans_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "trans",
      "");
  }

  if (!_xsd_normal_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "normal",
      "");
  }

  if (!_xsd_unit_.present ())
  {
    this->unit (
      unit::traits::create (
        ::std::basic_string< char > ("mS/cm"),
        &e,
        f | ::xml_schema::flags::not_root,
        this));
  }
}

conductivities_type* conductivities_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new conductivities_type (*this, f, c);
}

// time_steps_type
//

// time_steps_type::unit
//

const time_steps_type::unit::type time_steps_type::unit::default_value_ (
  ::std::basic_string< char > ("ms"), 0, 0, 0);

time_steps_type::
time_steps_type (const ode::type& _xsd_ode,
                 const pde::type& _xsd_pde,
                 const printing::type& _xsd_printing,
                 const unit::type& _xsd_unit)
: ::xml_schema::type (),
_xsd_ode_ (_xsd_ode,
           ::xml_schema::flags (),
           this),
_xsd_pde_ (_xsd_pde,
           ::xml_schema::flags (),
           this),
_xsd_printing_ (_xsd_printing,
                ::xml_schema::flags (),
                this),
_xsd_unit_ (_xsd_unit,
            ::xml_schema::flags (),
            this)
{
}

time_steps_type::
time_steps_type (const time_steps_type& _xsd_time_steps_type,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
: ::xml_schema::type (_xsd_time_steps_type, f, c),
_xsd_ode_ (_xsd_time_steps_type._xsd_ode_,
           f | ::xml_schema::flags::not_root,
           this),
_xsd_pde_ (_xsd_time_steps_type._xsd_pde_,
           f | ::xml_schema::flags::not_root,
           this),
_xsd_printing_ (_xsd_time_steps_type._xsd_printing_,
                f | ::xml_schema::flags::not_root,
                this),
_xsd_unit_ (_xsd_time_steps_type._xsd_unit_,
            f | ::xml_schema::flags::not_root,
            this)
{
}

time_steps_type::
time_steps_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_ode_ (f | ::xml_schema::flags::not_root, this),
_xsd_pde_ (f | ::xml_schema::flags::not_root, this),
_xsd_printing_ (f | ::xml_schema::flags::not_root, this),
_xsd_unit_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void time_steps_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_attributes ())
  {
    const ::xsd::cxx::xml::dom::attribute< char > a (p.next_attribute ());

    if (a.name () == "ode" && a.namespace_ ().empty ())
    {
      this->ode (
        ode::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }

    if (a.name () == "pde" && a.namespace_ ().empty ())
    {
      this->pde (
        pde::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }

    if (a.name () == "printing" && a.namespace_ ().empty ())
    {
      this->printing (
        printing::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));
      continue;
    }

    if (a.name () == "unit" && a.namespace_ ().empty ())
    {
      ::std::auto_ptr< unit::type > r (
        unit::traits::create (
          a.dom_attribute (),
          f | ::xml_schema::flags::not_root,
          this));

      this->unit (r);
      continue;
    }
  }

  if (!_xsd_ode_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "ode",
      "");
  }

  if (!_xsd_pde_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "pde",
      "");
  }

  if (!_xsd_printing_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "printing",
      "");
  }

  if (!_xsd_unit_.present ())
  {
    this->unit (
      unit::traits::create (
        ::std::basic_string< char > ("ms"),
        &e,
        f | ::xml_schema::flags::not_root,
        this));
  }
}

time_steps_type* time_steps_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new time_steps_type (*this, f, c);
}

// ksp_use_type
//

ksp_use_type::
ksp_use_type (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_ksp_use_type_convert ();
}

ksp_use_type::
ksp_use_type (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_ksp_use_type_convert ();
}

ksp_use_type::
ksp_use_type (const ::std::basic_string< char >& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_ksp_use_type_convert ();
}

ksp_use_type* ksp_use_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new ksp_use_type (*this, f, c);
}

ksp_use_type::_xsd_ksp_use_type ksp_use_type::
_xsd_ksp_use_type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ksp_use_type_literals_);
  const _xsd_ksp_use_type* i (::std::lower_bound (
                                _xsd_ksp_use_type_indexes_,
                                _xsd_ksp_use_type_indexes_ + 2,
                                *this,
                                c));

  if (i == _xsd_ksp_use_type_indexes_ + 2 || _xsd_ksp_use_type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ksp_use_type::
_xsd_ksp_use_type_literals_[2] =
{
  "relative",
  "absolute"
};

const ksp_use_type::_xsd_ksp_use_type ksp_use_type::
_xsd_ksp_use_type_indexes_[2] =
{
  ::ksp_use_type::absolute,
  ::ksp_use_type::relative
};

// ksp_tolerances_type
//

ksp_tolerances_type::
ksp_tolerances_type ()
: ::xml_schema::type (),
_xsd_KSPRelative_ (::xml_schema::flags (), this),
_xsd_KSPAbsolute_ (::xml_schema::flags (), this)
{
}

ksp_tolerances_type::
ksp_tolerances_type (const ksp_tolerances_type& _xsd_ksp_tolerances_type,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
: ::xml_schema::type (_xsd_ksp_tolerances_type, f, c),
_xsd_KSPRelative_ (_xsd_ksp_tolerances_type._xsd_KSPRelative_,
                   f | ::xml_schema::flags::not_root,
                   this),
_xsd_KSPAbsolute_ (_xsd_ksp_tolerances_type._xsd_KSPAbsolute_,
                   f | ::xml_schema::flags::not_root,
                   this)
{
}

ksp_tolerances_type::
ksp_tolerances_type (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_KSPRelative_ (f | ::xml_schema::flags::not_root, this),
_xsd_KSPAbsolute_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void ksp_tolerances_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // KSPRelative
    //
    {
      if (e.name () == "KSPRelative" && e.namespace_ ().empty ())
      {
        if (this->KSPRelative ())
          continue;
        this->KSPRelative (
          KSPRelative::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }
    }

    // KSPAbsolute
    //
    {
      if (e.name () == "KSPAbsolute" && e.namespace_ ().empty ())
      {
        if (this->KSPAbsolute ())
          continue;
        this->KSPAbsolute (
          KSPAbsolute::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }
    }
  }
}

ksp_tolerances_type* ksp_tolerances_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new ksp_tolerances_type (*this, f, c);
}

// ksp_solver_type
//

ksp_solver_type::
ksp_solver_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_ksp_solver_type_convert ();
}

ksp_solver_type::
ksp_solver_type (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_ksp_solver_type_convert ();
}

ksp_solver_type::
ksp_solver_type (const ::std::basic_string< char >& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_ksp_solver_type_convert ();
}

ksp_solver_type* ksp_solver_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new ksp_solver_type (*this, f, c);
}

ksp_solver_type::_xsd_ksp_solver_type ksp_solver_type::
_xsd_ksp_solver_type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ksp_solver_type_literals_);
  const _xsd_ksp_solver_type* i (::std::lower_bound (
                                   _xsd_ksp_solver_type_indexes_,
                                   _xsd_ksp_solver_type_indexes_ + 3,
                                   *this,
                                   c));

  if (i == _xsd_ksp_solver_type_indexes_ + 3 || _xsd_ksp_solver_type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ksp_solver_type::
_xsd_ksp_solver_type_literals_[3] =
{
  "cg",
  "symmlq",
  "gmres"
};

const ksp_solver_type::_xsd_ksp_solver_type ksp_solver_type::
_xsd_ksp_solver_type_indexes_[3] =
{
  ::ksp_solver_type::cg,
  ::ksp_solver_type::gmres,
  ::ksp_solver_type::symmlq
};

// ksp_preconditioner_type
//

ksp_preconditioner_type::
ksp_preconditioner_type (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_ksp_preconditioner_type_convert ();
}

ksp_preconditioner_type::
ksp_preconditioner_type (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_ksp_preconditioner_type_convert ();
}

ksp_preconditioner_type::
ksp_preconditioner_type (const ::std::basic_string< char >& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f,
                         ::xml_schema::type* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_ksp_preconditioner_type_convert ();
}

ksp_preconditioner_type* ksp_preconditioner_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new ksp_preconditioner_type (*this, f, c);
}

ksp_preconditioner_type::_xsd_ksp_preconditioner_type ksp_preconditioner_type::
_xsd_ksp_preconditioner_type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ksp_preconditioner_type_literals_);
  const _xsd_ksp_preconditioner_type* i (::std::lower_bound (
                                           _xsd_ksp_preconditioner_type_indexes_,
                                           _xsd_ksp_preconditioner_type_indexes_ + 5,
                                           *this,
                                           c));

  if (i == _xsd_ksp_preconditioner_type_indexes_ + 5 || _xsd_ksp_preconditioner_type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ksp_preconditioner_type::
_xsd_ksp_preconditioner_type_literals_[5] =
{
  "ilu",
  "jacobi",
  "bjacobi",
  "hypre",
  "none"
};

const ksp_preconditioner_type::_xsd_ksp_preconditioner_type ksp_preconditioner_type::
_xsd_ksp_preconditioner_type_indexes_[5] =
{
  ::ksp_preconditioner_type::bjacobi,
  ::ksp_preconditioner_type::hypre,
  ::ksp_preconditioner_type::ilu,
  ::ksp_preconditioner_type::jacobi,
  ::ksp_preconditioner_type::none
};

// simulation_type
//

// simulation_type::Stimuli::_xsd_Stimuli_::Stimuli
//

simulation_type::Stimuli::_xsd_Stimuli_::Stimuli::
Stimuli ()
: ::xml_schema::type (),
_xsd_Stimulus_ (::xml_schema::flags (), this)
{
}

simulation_type::Stimuli::_xsd_Stimuli_::Stimuli::
Stimuli (const Stimuli& _xsd_Stimuli,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
: ::xml_schema::type (_xsd_Stimuli, f, c),
_xsd_Stimulus_ (_xsd_Stimuli._xsd_Stimulus_,
                f | ::xml_schema::flags::not_root,
                this)
{
}

simulation_type::Stimuli::_xsd_Stimuli_::Stimuli::
Stimuli (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_Stimulus_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void simulation_type::Stimuli::_xsd_Stimuli_::Stimuli::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // Stimulus
    //
    {
      if (e.name () == "Stimulus" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< Stimulus::type > r (
          Stimulus::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        this->Stimulus ().push_back (r);
        continue;
      }
    }
  }
}

simulation_type::Stimuli::_xsd_Stimuli_::Stimuli* simulation_type::Stimuli::_xsd_Stimuli_::Stimuli::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new Stimuli (*this, f, c);
}

// simulation_type::CellHeterogeneities::_xsd_CellHeterogeneities_::CellHeterogeneities
//

simulation_type::CellHeterogeneities::_xsd_CellHeterogeneities_::CellHeterogeneities::
CellHeterogeneities ()
: ::xml_schema::type (),
_xsd_CellHeterogeneity_ (::xml_schema::flags (), this)
{
}

simulation_type::CellHeterogeneities::_xsd_CellHeterogeneities_::CellHeterogeneities::
CellHeterogeneities (const CellHeterogeneities& _xsd_CellHeterogeneities,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
: ::xml_schema::type (_xsd_CellHeterogeneities, f, c),
_xsd_CellHeterogeneity_ (_xsd_CellHeterogeneities._xsd_CellHeterogeneity_,
                         f | ::xml_schema::flags::not_root,
                         this)
{
}

simulation_type::CellHeterogeneities::_xsd_CellHeterogeneities_::CellHeterogeneities::
CellHeterogeneities (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_CellHeterogeneity_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void simulation_type::CellHeterogeneities::_xsd_CellHeterogeneities_::CellHeterogeneities::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // CellHeterogeneity
    //
    {
      if (e.name () == "CellHeterogeneity" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< CellHeterogeneity::type > r (
          CellHeterogeneity::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        this->CellHeterogeneity ().push_back (r);
        continue;
      }
    }
  }
}

simulation_type::CellHeterogeneities::_xsd_CellHeterogeneities_::CellHeterogeneities* simulation_type::CellHeterogeneities::_xsd_CellHeterogeneities_::CellHeterogeneities::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new CellHeterogeneities (*this, f, c);
}

// simulation_type::ConductivityHeterogeneities::_xsd_ConductivityHeterogeneities_::ConductivityHeterogeneities
//

simulation_type::ConductivityHeterogeneities::_xsd_ConductivityHeterogeneities_::ConductivityHeterogeneities::
ConductivityHeterogeneities ()
: ::xml_schema::type (),
_xsd_ConductivityHeterogeneity_ (::xml_schema::flags (), this)
{
}

simulation_type::ConductivityHeterogeneities::_xsd_ConductivityHeterogeneities_::ConductivityHeterogeneities::
ConductivityHeterogeneities (const ConductivityHeterogeneities& _xsd_ConductivityHeterogeneities,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
: ::xml_schema::type (_xsd_ConductivityHeterogeneities, f, c),
_xsd_ConductivityHeterogeneity_ (_xsd_ConductivityHeterogeneities._xsd_ConductivityHeterogeneity_,
                                 f | ::xml_schema::flags::not_root,
                                 this)
{
}

simulation_type::ConductivityHeterogeneities::_xsd_ConductivityHeterogeneities_::ConductivityHeterogeneities::
ConductivityHeterogeneities (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_ConductivityHeterogeneity_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void simulation_type::ConductivityHeterogeneities::_xsd_ConductivityHeterogeneities_::ConductivityHeterogeneities::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // ConductivityHeterogeneity
    //
    {
      if (e.name () == "ConductivityHeterogeneity" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< ConductivityHeterogeneity::type > r (
          ConductivityHeterogeneity::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        this->ConductivityHeterogeneity ().push_back (r);
        continue;
      }
    }
  }
}

simulation_type::ConductivityHeterogeneities::_xsd_ConductivityHeterogeneities_::ConductivityHeterogeneities* simulation_type::ConductivityHeterogeneities::_xsd_ConductivityHeterogeneities_::ConductivityHeterogeneities::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new ConductivityHeterogeneities (*this, f, c);
}

simulation_type::
simulation_type ()
: ::xml_schema::type (),
_xsd_SpaceDimension_ (::xml_schema::flags (), this),
_xsd_SimulationDuration_ (::xml_schema::flags (), this),
_xsd_Domain_ (::xml_schema::flags (), this),
_xsd_Mesh_ (::xml_schema::flags (), this),
_xsd_IonicModels_ (::xml_schema::flags (), this),
_xsd_Stimuli_ (::xml_schema::flags (), this),
_xsd_CellHeterogeneities_ (::xml_schema::flags (), this),
_xsd_ConductivityHeterogeneities_ (::xml_schema::flags (), this),
_xsd_OutputDirectory_ (::xml_schema::flags (), this),
_xsd_OutputFilenamePrefix_ (::xml_schema::flags (), this)
{
}

simulation_type::
simulation_type (const simulation_type& _xsd_simulation_type,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
: ::xml_schema::type (_xsd_simulation_type, f, c),
_xsd_SpaceDimension_ (_xsd_simulation_type._xsd_SpaceDimension_,
                      f | ::xml_schema::flags::not_root,
                      this),
_xsd_SimulationDuration_ (_xsd_simulation_type._xsd_SimulationDuration_,
                          f | ::xml_schema::flags::not_root,
                          this),
_xsd_Domain_ (_xsd_simulation_type._xsd_Domain_,
              f | ::xml_schema::flags::not_root,
              this),
_xsd_Mesh_ (_xsd_simulation_type._xsd_Mesh_,
            f | ::xml_schema::flags::not_root,
            this),
_xsd_IonicModels_ (_xsd_simulation_type._xsd_IonicModels_,
                   f | ::xml_schema::flags::not_root,
                   this),
_xsd_Stimuli_ (_xsd_simulation_type._xsd_Stimuli_,
               f | ::xml_schema::flags::not_root,
               this),
_xsd_CellHeterogeneities_ (_xsd_simulation_type._xsd_CellHeterogeneities_,
                           f | ::xml_schema::flags::not_root,
                           this),
_xsd_ConductivityHeterogeneities_ (_xsd_simulation_type._xsd_ConductivityHeterogeneities_,
                                   f | ::xml_schema::flags::not_root,
                                   this),
_xsd_OutputDirectory_ (_xsd_simulation_type._xsd_OutputDirectory_,
                       f | ::xml_schema::flags::not_root,
                       this),
_xsd_OutputFilenamePrefix_ (_xsd_simulation_type._xsd_OutputFilenamePrefix_,
                            f | ::xml_schema::flags::not_root,
                            this)
{
}

simulation_type::
simulation_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_SpaceDimension_ (f | ::xml_schema::flags::not_root, this),
_xsd_SimulationDuration_ (f | ::xml_schema::flags::not_root, this),
_xsd_Domain_ (f | ::xml_schema::flags::not_root, this),
_xsd_Mesh_ (f | ::xml_schema::flags::not_root, this),
_xsd_IonicModels_ (f | ::xml_schema::flags::not_root, this),
_xsd_Stimuli_ (f | ::xml_schema::flags::not_root, this),
_xsd_CellHeterogeneities_ (f | ::xml_schema::flags::not_root, this),
_xsd_ConductivityHeterogeneities_ (f | ::xml_schema::flags::not_root, this),
_xsd_OutputDirectory_ (f | ::xml_schema::flags::not_root, this),
_xsd_OutputFilenamePrefix_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void simulation_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // SpaceDimension
    //
    {
      if (e.name () == "SpaceDimension" && e.namespace_ ().empty ())
      {
        if (this->SpaceDimension ())
          continue;
        this->SpaceDimension (
          SpaceDimension::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));
        continue;
      }
    }

    // SimulationDuration
    //
    {
      if (e.name () == "SimulationDuration" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< SimulationDuration::type > r (
          SimulationDuration::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->SimulationDuration ())
          continue;
        this->SimulationDuration (r);
        continue;
      }
    }

    // Domain
    //
    {
      if (e.name () == "Domain" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< Domain::type > r (
          Domain::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->Domain ())
          continue;
        this->Domain (r);
        continue;
      }
    }

    // Mesh
    //
    {
      if (e.name () == "Mesh" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< Mesh::type > r (
          Mesh::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->Mesh ())
          continue;
        this->Mesh (r);
        continue;
      }
    }

    // IonicModels
    //
    {
      if (e.name () == "IonicModels" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< IonicModels::type > r (
          IonicModels::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->IonicModels ())
          continue;
        this->IonicModels (r);
        continue;
      }
    }

    // Stimuli
    //
    {
      if (e.name () == "Stimuli" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< Stimuli::type > r (
          Stimuli::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->Stimuli ())
          continue;
        this->Stimuli (r);
        continue;
      }
    }

    // CellHeterogeneities
    //
    {
      if (e.name () == "CellHeterogeneities" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< CellHeterogeneities::type > r (
          CellHeterogeneities::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->CellHeterogeneities ())
          continue;
        this->CellHeterogeneities (r);
        continue;
      }
    }

    // ConductivityHeterogeneities
    //
    {
      if (e.name () == "ConductivityHeterogeneities" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< ConductivityHeterogeneities::type > r (
          ConductivityHeterogeneities::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->ConductivityHeterogeneities ())
          continue;
        this->ConductivityHeterogeneities (r);
        continue;
      }
    }

    // OutputDirectory
    //
    {
      if (e.name () == "OutputDirectory" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< OutputDirectory::type > r (
          OutputDirectory::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->OutputDirectory ())
          continue;
        this->OutputDirectory (r);
        continue;
      }
    }

    // OutputFilenamePrefix
    //
    {
      if (e.name () == "OutputFilenamePrefix" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< OutputFilenamePrefix::type > r (
          OutputFilenamePrefix::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->OutputFilenamePrefix ())
          continue;
        this->OutputFilenamePrefix (r);
        continue;
      }
    }
  }
}

simulation_type* simulation_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new simulation_type (*this, f, c);
}

// physiological_type
//

physiological_type::
physiological_type ()
: ::xml_schema::type (),
_xsd_IntracellularConductivities_ (::xml_schema::flags (), this),
_xsd_ExtracellularConductivities_ (::xml_schema::flags (), this),
_xsd_BathConductivity_ (::xml_schema::flags (), this),
_xsd_SurfaceAreaToVolumeRatio_ (::xml_schema::flags (), this),
_xsd_Capacitance_ (::xml_schema::flags (), this)
{
}

physiological_type::
physiological_type (const physiological_type& _xsd_physiological_type,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
: ::xml_schema::type (_xsd_physiological_type, f, c),
_xsd_IntracellularConductivities_ (_xsd_physiological_type._xsd_IntracellularConductivities_,
                                   f | ::xml_schema::flags::not_root,
                                   this),
_xsd_ExtracellularConductivities_ (_xsd_physiological_type._xsd_ExtracellularConductivities_,
                                   f | ::xml_schema::flags::not_root,
                                   this),
_xsd_BathConductivity_ (_xsd_physiological_type._xsd_BathConductivity_,
                        f | ::xml_schema::flags::not_root,
                        this),
_xsd_SurfaceAreaToVolumeRatio_ (_xsd_physiological_type._xsd_SurfaceAreaToVolumeRatio_,
                                f | ::xml_schema::flags::not_root,
                                this),
_xsd_Capacitance_ (_xsd_physiological_type._xsd_Capacitance_,
                   f | ::xml_schema::flags::not_root,
                   this)
{
}

physiological_type::
physiological_type (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_IntracellularConductivities_ (f | ::xml_schema::flags::not_root, this),
_xsd_ExtracellularConductivities_ (f | ::xml_schema::flags::not_root, this),
_xsd_BathConductivity_ (f | ::xml_schema::flags::not_root, this),
_xsd_SurfaceAreaToVolumeRatio_ (f | ::xml_schema::flags::not_root, this),
_xsd_Capacitance_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void physiological_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // IntracellularConductivities
    //
    {
      if (e.name () == "IntracellularConductivities" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< IntracellularConductivities::type > r (
          IntracellularConductivities::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->IntracellularConductivities ())
          continue;
        this->IntracellularConductivities (r);
        continue;
      }
    }

    // ExtracellularConductivities
    //
    {
      if (e.name () == "ExtracellularConductivities" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< ExtracellularConductivities::type > r (
          ExtracellularConductivities::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->ExtracellularConductivities ())
          continue;
        this->ExtracellularConductivities (r);
        continue;
      }
    }

    // BathConductivity
    //
    {
      if (e.name () == "BathConductivity" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< BathConductivity::type > r (
          BathConductivity::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->BathConductivity ())
          continue;
        this->BathConductivity (r);
        continue;
      }
    }

    // SurfaceAreaToVolumeRatio
    //
    {
      if (e.name () == "SurfaceAreaToVolumeRatio" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< SurfaceAreaToVolumeRatio::type > r (
          SurfaceAreaToVolumeRatio::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->SurfaceAreaToVolumeRatio ())
          continue;
        this->SurfaceAreaToVolumeRatio (r);
        continue;
      }
    }

    // Capacitance
    //
    {
      if (e.name () == "Capacitance" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< Capacitance::type > r (
          Capacitance::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->Capacitance ())
          continue;
        this->Capacitance (r);
        continue;
      }
    }
  }
}

physiological_type* physiological_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new physiological_type (*this, f, c);
}

// numerical_type
//

numerical_type::
numerical_type ()
: ::xml_schema::type (),
_xsd_TimeSteps_ (::xml_schema::flags (), this),
_xsd_KSPTolerances_ (::xml_schema::flags (), this),
_xsd_KSPSolver_ (::xml_schema::flags (), this),
_xsd_KSPPreconditioner_ (::xml_schema::flags (), this)
{
}

numerical_type::
numerical_type (const numerical_type& _xsd_numerical_type,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
: ::xml_schema::type (_xsd_numerical_type, f, c),
_xsd_TimeSteps_ (_xsd_numerical_type._xsd_TimeSteps_,
                 f | ::xml_schema::flags::not_root,
                 this),
_xsd_KSPTolerances_ (_xsd_numerical_type._xsd_KSPTolerances_,
                     f | ::xml_schema::flags::not_root,
                     this),
_xsd_KSPSolver_ (_xsd_numerical_type._xsd_KSPSolver_,
                 f | ::xml_schema::flags::not_root,
                 this),
_xsd_KSPPreconditioner_ (_xsd_numerical_type._xsd_KSPPreconditioner_,
                         f | ::xml_schema::flags::not_root,
                         this)
{
}

numerical_type::
numerical_type (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_TimeSteps_ (f | ::xml_schema::flags::not_root, this),
_xsd_KSPTolerances_ (f | ::xml_schema::flags::not_root, this),
_xsd_KSPSolver_ (f | ::xml_schema::flags::not_root, this),
_xsd_KSPPreconditioner_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void numerical_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // TimeSteps
    //
    {
      if (e.name () == "TimeSteps" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< TimeSteps::type > r (
          TimeSteps::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->TimeSteps ())
          continue;
        this->TimeSteps (r);
        continue;
      }
    }

    // KSPTolerances
    //
    {
      if (e.name () == "KSPTolerances" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< KSPTolerances::type > r (
          KSPTolerances::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->KSPTolerances ())
          continue;
        this->KSPTolerances (r);
        continue;
      }
    }

    // KSPSolver
    //
    {
      if (e.name () == "KSPSolver" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< KSPSolver::type > r (
          KSPSolver::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->KSPSolver ())
          continue;
        this->KSPSolver (r);
        continue;
      }
    }

    // KSPPreconditioner
    //
    {
      if (e.name () == "KSPPreconditioner" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< KSPPreconditioner::type > r (
          KSPPreconditioner::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (this->KSPPreconditioner ())
          continue;
        this->KSPPreconditioner (r);
        continue;
      }
    }
  }
}

numerical_type* numerical_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new numerical_type (*this, f, c);
}

// chaste_parameters_type
//

chaste_parameters_type::
chaste_parameters_type (const Simulation::type& _xsd_Simulation,
                        const Physiological::type& _xsd_Physiological,
                        const Numerical::type& _xsd_Numerical)
: ::xml_schema::type (),
_xsd_Simulation_ (_xsd_Simulation,
                  ::xml_schema::flags (),
                  this),
_xsd_Physiological_ (_xsd_Physiological,
                     ::xml_schema::flags (),
                     this),
_xsd_Numerical_ (_xsd_Numerical,
                 ::xml_schema::flags (),
                 this)
{
}

chaste_parameters_type::
chaste_parameters_type (const chaste_parameters_type& _xsd_chaste_parameters_type,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
: ::xml_schema::type (_xsd_chaste_parameters_type, f, c),
_xsd_Simulation_ (_xsd_chaste_parameters_type._xsd_Simulation_,
                  f | ::xml_schema::flags::not_root,
                  this),
_xsd_Physiological_ (_xsd_chaste_parameters_type._xsd_Physiological_,
                     f | ::xml_schema::flags::not_root,
                     this),
_xsd_Numerical_ (_xsd_chaste_parameters_type._xsd_Numerical_,
                 f | ::xml_schema::flags::not_root,
                 this)
{
}

chaste_parameters_type::
chaste_parameters_type (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::type* c)
: ::xml_schema::type (e, f, c),
_xsd_Simulation_ (f | ::xml_schema::flags::not_root, this),
_xsd_Physiological_ (f | ::xml_schema::flags::not_root, this),
_xsd_Numerical_ (f | ::xml_schema::flags::not_root, this)
{
  parse (e, f);
}

void chaste_parameters_type::
parse (const ::xercesc::DOMElement& e, ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::parser< char > p (e);

  while (p.more_elements ())
  {
    const ::xsd::cxx::xml::dom::element< char > e (p.next_element ());

    // Simulation
    //
    {
      if (e.name () == "Simulation" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< Simulation::type > r (
          Simulation::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_Simulation_.present ())
          continue;
        this->Simulation (r);
        continue;
      }
    }

    // Physiological
    //
    {
      if (e.name () == "Physiological" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< Physiological::type > r (
          Physiological::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_Physiological_.present ())
          continue;
        this->Physiological (r);
        continue;
      }
    }

    // Numerical
    //
    {
      if (e.name () == "Numerical" && e.namespace_ ().empty ())
      {
        ::std::auto_ptr< Numerical::type > r (
          Numerical::traits::create (
            e.dom_element (),
            f | ::xml_schema::flags::not_root,
            this));

        if (_xsd_Numerical_.present ())
          continue;
        this->Numerical (r);
        continue;
      }
    }
  }

  if (!_xsd_Simulation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Simulation",
      "");
  }

  if (!_xsd_Physiological_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Physiological",
      "");
  }

  if (!_xsd_Numerical_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Numerical",
      "");
  }
}

chaste_parameters_type* chaste_parameters_type::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new chaste_parameters_type (*this, f, c);
}

#include <istream>
#include <xercesc/framework/Wrapper4InputSource.hpp>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::chaste_parameters_type >
ChasteParameters (const ::std::basic_string< char >& u,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::ChasteParameters (
    static_cast< const ::xercesc::DOMDocument& > (*d), f);
}

::std::auto_ptr< ::chaste_parameters_type >
ChasteParameters (const ::std::basic_string< char >& u,
                  ::xsd::cxx::xml::error_handler< char >& h,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d)
  {
    throw ::xsd::cxx::tree::parsing< char > ();
  }

  return ::ChasteParameters (
    static_cast< const ::xercesc::DOMDocument& > (*d), f);
}

::std::auto_ptr< ::chaste_parameters_type >
ChasteParameters (const ::std::basic_string< char >& u,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d)
  {
    throw ::xsd::cxx::tree::parsing< char > ();
  }

  return ::ChasteParameters (
    static_cast< const ::xercesc::DOMDocument& > (*d), f);
}

::std::auto_ptr< ::chaste_parameters_type >
ChasteParameters (::std::istream& is,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  ::xercesc::Wrapper4InputSource wrap (&isrc, false);
  return ::ChasteParameters (wrap, f, p);
}

::std::auto_ptr< ::chaste_parameters_type >
ChasteParameters (::std::istream& is,
                  ::xsd::cxx::xml::error_handler< char >& h,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  ::xercesc::Wrapper4InputSource wrap (&isrc, false);
  return ::ChasteParameters (wrap, h, f, p);
}

::std::auto_ptr< ::chaste_parameters_type >
ChasteParameters (::std::istream& is,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  ::xercesc::Wrapper4InputSource wrap (&isrc, false);
  return ::ChasteParameters (wrap, h, f, p);
}

::std::auto_ptr< ::chaste_parameters_type >
ChasteParameters (::std::istream& is,
                  const ::std::basic_string< char >& sid,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  ::xercesc::Wrapper4InputSource wrap (&isrc, false);
  return ::ChasteParameters (wrap, f, p);
}

::std::auto_ptr< ::chaste_parameters_type >
ChasteParameters (::std::istream& is,
                  const ::std::basic_string< char >& sid,
                  ::xsd::cxx::xml::error_handler< char >& h,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  ::xercesc::Wrapper4InputSource wrap (&isrc, false);
  return ::ChasteParameters (wrap, h, f, p);
}

::std::auto_ptr< ::chaste_parameters_type >
ChasteParameters (::std::istream& is,
                  const ::std::basic_string< char >& sid,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  ::xercesc::Wrapper4InputSource wrap (&isrc, false);
  return ::ChasteParameters (wrap, h, f, p);
}

::std::auto_ptr< ::chaste_parameters_type >
ChasteParameters (const ::xercesc::DOMInputSource& i,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::ChasteParameters (
    static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
}

::std::auto_ptr< ::chaste_parameters_type >
ChasteParameters (const ::xercesc::DOMInputSource& i,
                  ::xsd::cxx::xml::error_handler< char >& h,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d)
  {
    throw ::xsd::cxx::tree::parsing< char > ();
  }

  return ::ChasteParameters (
    static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
}

::std::auto_ptr< ::chaste_parameters_type >
ChasteParameters (const ::xercesc::DOMInputSource& i,
                  ::xercesc::DOMErrorHandler& h,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< char >& p)
{
  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d)
  {
    throw ::xsd::cxx::tree::parsing< char > ();
  }

  return ::ChasteParameters (
    static_cast< const ::xercesc::DOMDocument& > (*d), f, p);
}

::std::auto_ptr< ::chaste_parameters_type >
ChasteParameters (const ::xercesc::DOMDocument& d,
                  ::xml_schema::flags f,
                  const ::xsd::cxx::tree::properties< char >&)
{
  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
    (f & ::xml_schema::flags::keep_dom)
    ? static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true))
    : 0);

  const ::xsd::cxx::xml::dom::element< char > e (
    c.get ()
    ? *c->getDocumentElement ()
    : *d.getDocumentElement ());

  if (e.name () == "ChasteParameters" &&
      e.namespace_ () == "")
  {
    ::std::auto_ptr< ::chaste_parameters_type > r (
      ::xsd::cxx::tree::traits< ::chaste_parameters_type, char >::create (
        e.dom_element (), f, 0));
    if (f & ::xml_schema::flags::keep_dom) c.release ();
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    e.name (),
    e.namespace_ (),
    "ChasteParameters",
    "");
}

#include <ostream>
#include <xsd/cxx/xml/dom/elements.hxx>
#include <xsd/cxx/xml/dom/serialization.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

void
operator<< (::xercesc::DOMElement& e,
            const time_type& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type >& > (i);

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "unit",
      e);

    a.dom_attribute () << i.unit ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const dimensionless_type& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type >& > (i);

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "unit",
      e);

    a.dom_attribute () << i.unit ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const conductivity_type& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type >& > (i);

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "unit",
      e);

    a.dom_attribute () << i.unit ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const stimulus_strength_type& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type >& > (i);

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "unit",
      e);

    a.dom_attribute () << i.unit ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const inverse_length_type& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type >& > (i);

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "unit",
      e);

    a.dom_attribute () << i.unit ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const capacitance_type& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type >& > (i);

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "unit",
      e);

    a.dom_attribute () << i.unit ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const location_type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "Cuboid",
      e);
    s.dom_element () << i.Cuboid ();
  }

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "unit",
      e);

    a.dom_attribute () << i.unit ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            domain_type i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,
            domain_type i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xsd::cxx::tree::list_stream< char >& l,
            domain_type i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e,
            ionic_models_available_type i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,
            ionic_models_available_type i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xsd::cxx::tree::list_stream< char >& l,
            ionic_models_available_type i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e,
            const ionic_model_region_type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "IonicModel",
      e);
    s.dom_element () << i.IonicModel ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "Location",
      e);
    s.dom_element () << i.Location ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const ionic_models_type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "Default",
      e);
    s.dom_element () << i.Default ();
  }

  {
    for (ionic_models_type::Region::const_iterator
         b (i.Region ().begin ()), n (i.Region ().end ());
         b != n; ++b)
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "Region",
        e);
      s.dom_element () << *b;
    }
  }
}

void
operator<< (::xercesc::DOMElement& e,
            media_type i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,
            media_type i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xsd::cxx::tree::list_stream< char >& l,
            media_type i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e,
            const point_type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "x",
      e);

    a.dom_attribute () << i.x ();
  }

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "y",
      e);

    a.dom_attribute () << i.y ();
  }

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "z",
      e);

    a.dom_attribute () << i.z ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const box_type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "LowerCoordinates",
      e);
    s.dom_element () << i.LowerCoordinates ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "UpperCoordinates",
      e);
    s.dom_element () << i.UpperCoordinates ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const stimulus_type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "Strength",
      e);
    s.dom_element () << i.Strength ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "Duration",
      e);
    s.dom_element () << i.Duration ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "Delay",
      e);
    s.dom_element () << i.Delay ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "Location",
      e);
    s.dom_element () << i.Location ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const cell_heterogeneity_type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "ScaleFactorGks",
      e);
    s.dom_element () << i.ScaleFactorGks ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "ScaleFactorIto",
      e);
    s.dom_element () << i.ScaleFactorIto ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "ScaleFactorGkr",
      e);
    s.dom_element () << i.ScaleFactorGkr ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "Location",
      e);
    s.dom_element () << i.Location ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const conductivity_heterogeneity_type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    if (i.IntracellularConductivities ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "IntracellularConductivities",
        e);
      s.dom_element () << *i.IntracellularConductivities ();
    }
  }

  {
    if (i.ExtracellularConductivities ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "ExtracellularConductivities",
        e);
      s.dom_element () << *i.ExtracellularConductivities ();
    }
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "Location",
      e);
    s.dom_element () << i.Location ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const slab_type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "x",
      e);

    a.dom_attribute () << i.x ();
  }

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "y",
      e);

    a.dom_attribute () << i.y ();
  }

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "z",
      e);

    a.dom_attribute () << i.z ();
  }

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "inter_node_space",
      e);

    a.dom_attribute () << i.inter_node_space ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const sheet_type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "x",
      e);

    a.dom_attribute () << i.x ();
  }

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "y",
      e);

    a.dom_attribute () << i.y ();
  }

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "inter_node_space",
      e);

    a.dom_attribute () << i.inter_node_space ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const fibre_type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "x",
      e);

    a.dom_attribute () << i.x ();
  }

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "inter_node_space",
      e);

    a.dom_attribute () << i.inter_node_space ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const load_mesh_type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "name",
      e);

    a.dom_attribute () << i.name ();
  }

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "conductivity_media",
      e);

    a.dom_attribute () << i.conductivity_media ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const mesh_type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    if (i.Slab ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "Slab",
        e);
      s.dom_element () << *i.Slab ();
    }
  }

  {
    if (i.Sheet ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "Sheet",
        e);
      s.dom_element () << *i.Sheet ();
    }
  }

  {
    if (i.Fibre ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "Fibre",
        e);
      s.dom_element () << *i.Fibre ();
    }
  }

  {
    if (i.LoadMesh ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "LoadMesh",
        e);
      s.dom_element () << *i.LoadMesh ();
    }
  }

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "unit",
      e);

    a.dom_attribute () << i.unit ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const conductivities_type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "longi",
      e);

    a.dom_attribute () << i.longi ();
  }

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "trans",
      e);

    a.dom_attribute () << i.trans ();
  }

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "normal",
      e);

    a.dom_attribute () << i.normal ();
  }

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "unit",
      e);

    a.dom_attribute () << i.unit ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const time_steps_type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "ode",
      e);

    a.dom_attribute () << i.ode ();
  }

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "pde",
      e);

    a.dom_attribute () << i.pde ();
  }

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "printing",
      e);

    a.dom_attribute () << i.printing ();
  }

  {
    ::xsd::cxx::xml::dom::attribute< char > a (
      "unit",
      e);

    a.dom_attribute () << i.unit ();
  }
}

void
operator<< (::xercesc::DOMElement& e,
            ksp_use_type i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,
            ksp_use_type i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xsd::cxx::tree::list_stream< char >& l,
            ksp_use_type i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e,
            const ksp_tolerances_type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    if (i.KSPRelative ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "KSPRelative",
        e);
      s.dom_element () << *i.KSPRelative ();
    }
  }

  {
    if (i.KSPAbsolute ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "KSPAbsolute",
        e);
      s.dom_element () << *i.KSPAbsolute ();
    }
  }
}

void
operator<< (::xercesc::DOMElement& e,
            ksp_solver_type i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,
            ksp_solver_type i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xsd::cxx::tree::list_stream< char >& l,
            ksp_solver_type i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e,
            ksp_preconditioner_type i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a,
            ksp_preconditioner_type i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xsd::cxx::tree::list_stream< char >& l,
            ksp_preconditioner_type i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e,
            const simulation_type::Stimuli::type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    for (simulation_type::Stimuli::type::Stimulus::const_iterator
         b (i.Stimulus ().begin ()), n (i.Stimulus ().end ());
         b != n; ++b)
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "Stimulus",
        e);
      s.dom_element () << *b;
    }
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const simulation_type::CellHeterogeneities::type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    for (simulation_type::CellHeterogeneities::type::CellHeterogeneity::const_iterator
         b (i.CellHeterogeneity ().begin ()), n (i.CellHeterogeneity ().end ());
         b != n; ++b)
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "CellHeterogeneity",
        e);
      s.dom_element () << *b;
    }
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const simulation_type::ConductivityHeterogeneities::type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    for (simulation_type::ConductivityHeterogeneities::type::ConductivityHeterogeneity::const_iterator
         b (i.ConductivityHeterogeneity ().begin ()), n (i.ConductivityHeterogeneity ().end ());
         b != n; ++b)
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "ConductivityHeterogeneity",
        e);
      s.dom_element () << *b;
    }
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const simulation_type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    if (i.SpaceDimension ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "SpaceDimension",
        e);
      s.dom_element () << *i.SpaceDimension ();
    }
  }

  {
    if (i.SimulationDuration ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "SimulationDuration",
        e);
      s.dom_element () << *i.SimulationDuration ();
    }
  }

  {
    if (i.Domain ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "Domain",
        e);
      s.dom_element () << *i.Domain ();
    }
  }

  {
    if (i.Mesh ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "Mesh",
        e);
      s.dom_element () << *i.Mesh ();
    }
  }

  {
    if (i.IonicModels ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "IonicModels",
        e);
      s.dom_element () << *i.IonicModels ();
    }
  }

  {
    if (i.Stimuli ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "Stimuli",
        e);
      s.dom_element () << *i.Stimuli ();
    }
  }

  {
    if (i.CellHeterogeneities ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "CellHeterogeneities",
        e);
      s.dom_element () << *i.CellHeterogeneities ();
    }
  }

  {
    if (i.ConductivityHeterogeneities ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "ConductivityHeterogeneities",
        e);
      s.dom_element () << *i.ConductivityHeterogeneities ();
    }
  }

  {
    if (i.OutputDirectory ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "OutputDirectory",
        e);
      s.dom_element () << *i.OutputDirectory ();
    }
  }

  {
    if (i.OutputFilenamePrefix ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "OutputFilenamePrefix",
        e);
      s.dom_element () << *i.OutputFilenamePrefix ();
    }
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const physiological_type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    if (i.IntracellularConductivities ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "IntracellularConductivities",
        e);
      s.dom_element () << *i.IntracellularConductivities ();
    }
  }

  {
    if (i.ExtracellularConductivities ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "ExtracellularConductivities",
        e);
      s.dom_element () << *i.ExtracellularConductivities ();
    }
  }

  {
    if (i.BathConductivity ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "BathConductivity",
        e);
      s.dom_element () << *i.BathConductivity ();
    }
  }

  {
    if (i.SurfaceAreaToVolumeRatio ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "SurfaceAreaToVolumeRatio",
        e);
      s.dom_element () << *i.SurfaceAreaToVolumeRatio ();
    }
  }

  {
    if (i.Capacitance ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "Capacitance",
        e);
      s.dom_element () << *i.Capacitance ();
    }
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const numerical_type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    if (i.TimeSteps ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "TimeSteps",
        e);
      s.dom_element () << *i.TimeSteps ();
    }
  }

  {
    if (i.KSPTolerances ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "KSPTolerances",
        e);
      s.dom_element () << *i.KSPTolerances ();
    }
  }

  {
    if (i.KSPSolver ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "KSPSolver",
        e);
      s.dom_element () << *i.KSPSolver ();
    }
  }

  {
    if (i.KSPPreconditioner ())
    {
      ::xsd::cxx::xml::dom::element< char > s (
        "KSPPreconditioner",
        e);
      s.dom_element () << *i.KSPPreconditioner ();
    }
  }
}

void
operator<< (::xercesc::DOMElement& e,
            const chaste_parameters_type& i)
{
  while (::xercesc::DOMNode* n = e.getFirstChild ())
    e.removeChild (n);

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "Simulation",
      e);
    s.dom_element () << i.Simulation ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "Physiological",
      e);
    s.dom_element () << i.Physiological ();
  }

  {
    ::xsd::cxx::xml::dom::element< char > s (
      "Numerical",
      e);
    s.dom_element () << i.Numerical ();
  }
}

void
ChasteParameters (::xercesc::DOMDocument& d,
                  const ::chaste_parameters_type& s,
                  ::xml_schema::flags)
{
  ::xsd::cxx::xml::dom::element< char > e (*d.getDocumentElement ());

  if (e.name () == "ChasteParameters" &&
      e.namespace_ () == "")
  {
    e.dom_element () << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      e.name (),
      e.namespace_ (),
      "ChasteParameters",
      "");
  }
}

::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument >
ChasteParameters (const ::chaste_parameters_type& s,
                  const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
                  ::xml_schema::flags f)
{
  try
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "ChasteParameters",
        "",
        m,
        f));
    ::ChasteParameters (*d, s, f);
    return d;
  }
  catch (const ::xsd::cxx::xml::dom::mapping< char >& e)
  {
    throw ::xsd::cxx::tree::no_namespace_mapping< char > (e.name ());
  }
  catch (const ::xsd::cxx::xml::dom::xsi_already_in_use&)
  {
    throw ::xsd::cxx::tree::xsi_already_in_use< char > ();
  }
}

void
ChasteParameters (::xercesc::XMLFormatTarget& t,
                  const ::chaste_parameters_type& s,
                  const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
                  const ::std::basic_string< char >& e,
                  ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::ChasteParameters (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
ChasteParameters (::xercesc::XMLFormatTarget& t,
                  const ::chaste_parameters_type& s,
                  const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
                  ::xsd::cxx::xml::error_handler< char >& h,
                  const ::std::basic_string< char >& e,
                  ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::ChasteParameters (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
ChasteParameters (::xercesc::XMLFormatTarget& t,
                  const ::chaste_parameters_type& s,
                  const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::basic_string< char >& e,
                  ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::ChasteParameters (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
ChasteParameters (::std::ostream& o,
                  const ::chaste_parameters_type& s,
                  const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
                  const ::std::basic_string< char >& e,
                  ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::ChasteParameters (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
ChasteParameters (::std::ostream& o,
                  const ::chaste_parameters_type& s,
                  const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
                  ::xsd::cxx::xml::error_handler< char >& h,
                  const ::std::basic_string< char >& e,
                  ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::ChasteParameters (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
ChasteParameters (::std::ostream& o,
                  const ::chaste_parameters_type& s,
                  const ::xsd::cxx::xml::dom::namespace_infomap< char >& m,
                  ::xercesc::DOMErrorHandler& h,
                  const ::std::basic_string< char >& e,
                  ::xml_schema::flags f)
{
  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::ChasteParameters (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
#undef COVERAGE_IGNORE
//
// End epilogue.

