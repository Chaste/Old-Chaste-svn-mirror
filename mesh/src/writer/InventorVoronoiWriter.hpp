#ifndef INVENTORVORONOIWRITER_HPP_
#define INVENTORVORONOIWRITER_HPP_

#include "OutputFileHandler.hpp"

const std::string inventor_header="#Inventor V2.0 ascii \n\
\n\
Separator { \n\
  Info { \n\
    string \"tetrahedron.iv generated by IVREAD.\" \n\
    string \"Original data in file tetrahedron.wrl.\" \n\
  } \n\
  Separator { \n\
    LightModel { \n\
      model BASE_COLOR \n\
    } \n\
\n\
    Material { \n\
      ambientColor  0.2 0.2 0.2 \n\
\n\
      emissiveColor 0.0 0.0 0.0 \n\
      specularColor 1.0 1.0 1.0 \n\
      shininess     0.2 \n\
\n\
    } \n\
    ShapeHints { \n\
      vertexOrdering COUNTERCLOCKWISE \n\
      shapeType UNKNOWN_SHAPE_TYPE \n\
      faceType CONVEX \n\
      creaseAngle 6.28319 \n\
    } \n\
\n\
    DrawStyle { \n\
        style           LINES \n\
        lineWidth           3 \n\
        linePattern       255 \n\
    } \n\
\n\
    Coordinate3 { \n\
      point [ \n\
";

const std::string inventor_mid="      ] \n\
    } \n\
    IndexedFaceSet { \n\
      coordIndex [ \n\
";

const std::string inventor_footer="      ] \n\
    } \n\
  } \n\
} \n\
";
class InventorVoronoiWriter
{
protected:
    OutputFileHandler *mpOutputFileHandler; /**< Output file handler */
    std::string mBaseName; /**< Base name for the input files */
    
public:
    /** Constructor */
    InventorVoronoiWriter(const std::string &rDirectory,
                          const std::string &rBaseName,
                          const bool clearOutputDir=true)
            : mBaseName(rBaseName)
    {
        mpOutputFileHandler = new OutputFileHandler(rDirectory, clearOutputDir);
    }
    
    /** Destructor */
    ~InventorVoronoiWriter()
    {
        delete mpOutputFileHandler;
    }
    
    void Write(const VoronoiTessellation& rTessellation)
    {
        // open inventor file
        std::string file_name = this->mBaseName+".iv";
        out_stream p_file = this->mpOutputFileHandler->OpenOutputFile(file_name);
        
        // write out header part of file      

        *p_file << inventor_header;
        
        // write out vertices
        // and construct map from pointer to vertex to vertex number
        
        std::map< c_vector<double, 3>*, unsigned> vertex_number_map;
        for ( unsigned vertex_number=0;
              vertex_number<rTessellation.mVertices.size();
              vertex_number++ )
        {
            c_vector<double ,3>& vertex=*(rTessellation.mVertices[vertex_number]);
            *p_file << "        " << vertex(0) << " " << vertex(1) << " " << vertex(2) << ",\n";
            
            vertex_number_map[rTessellation.mVertices[vertex_number]]=vertex_number;
        }
        
        *p_file << inventor_mid;
        
        // write out faces;
        
        for (unsigned face_number=0;
             face_number < rTessellation.mFaces.size();
             face_number++)
        {
            *p_file << "        ";
            Face& face=*(rTessellation.mFaces[face_number]);
            for (unsigned vertex_local_number=0;
                 vertex_local_number < face.mVertices.size();
                 vertex_local_number++)
            {
                // note this assumes we can definitely find the vertex in the map
                unsigned vertex_number=vertex_number_map[face.mVertices[vertex_local_number]];
                *p_file << vertex_number << ", ";
            }
            *p_file << "\n";
        }
        *p_file << inventor_footer;
    }
    
    
    void ScaleAndWrite(VoronoiTessellation& rTessellation, double scaleFactor)
    {
        if ((scaleFactor <= 0.0) || (scaleFactor > 1.0))
        {
            EXCEPTION("scaleFactor should be between 0 and 1");
        }
        
        // open inventor file
        std::string file_name = this->mBaseName+".iv";
        out_stream p_file = this->mpOutputFileHandler->OpenOutputFile(file_name);
        
        // write out header part of file      
        *p_file << inventor_header;
        
        unsigned global_vertex_number = 0;

        // the face data which will be written to file afterwards
        std::vector<std::vector<unsigned> > new_faces_data;
        std::vector<unsigned> number_faces_per_cell;
        
        // loop over cells and write out scaled vertices for each one, storing face info as we go
        for (unsigned cell_index = 0; cell_index<rTessellation.mVoronoiCells.size(); cell_index++)
        {
            c_vector<double, 3>& r_cell_centre = rTessellation.mVoronoiCells[cell_index].rGetVoronoiCellCentre();

            // map from position to (new) global vertex number, for this cell only
            std::map< c_vector<double, 3>*, unsigned> vertex_number_map;

            const VoronoiCell& r_cell = rTessellation.mVoronoiCells[cell_index];
            
            for (unsigned face_number=0; face_number<r_cell.mFaces.size(); face_number++)
            {
                std::vector<unsigned> face_vertex_data;

                Face& r_face = *(r_cell.mFaces[face_number]);
                for (unsigned face_vertex_number=0; face_vertex_number<r_face.mVertices.size(); face_vertex_number++)
                {
                    unsigned global_number_for_this_vertex;
                    
                    // see if vertex is in the map
                    std::map< c_vector<double,3>*,unsigned>::iterator iter = vertex_number_map.find(r_face.mVertices[face_vertex_number]);
                    if(iter!=vertex_number_map.end())
                    {
                        global_number_for_this_vertex = iter->second;
                    }
                    else
                    {
                        global_number_for_this_vertex = global_vertex_number;

                        // not in the map, so add it to map
                        vertex_number_map[r_face.mVertices[face_vertex_number]] = global_number_for_this_vertex;
                        global_vertex_number++;
                        
                        // scale the vertex and print out the new position
                        c_vector<double,3> new_vertex = *(r_face.mVertices[face_vertex_number]);
                        new_vertex = scaleFactor*(new_vertex - r_cell_centre) + r_cell_centre;

                        *p_file << "        " << new_vertex(0) << " " << new_vertex(1) << " " << new_vertex(2) << ",\n";
                    }
                    
                    // store this vertex's global number as a vertex for this face
                    face_vertex_data.push_back(global_number_for_this_vertex);
                }

                // add the vertex data for this face to the store
                new_faces_data.push_back( face_vertex_data );
            }
            number_faces_per_cell.push_back(r_cell.mFaces.size());
        }

        unsigned index=0;
        
        for(unsigned i=0; i<number_faces_per_cell.size(); i++)
        {
            if(number_faces_per_cell[i]>0)
            {
                *p_file << inventor_mid;

                for(unsigned j=0; j<number_faces_per_cell[i]; j++)
                {
                    *p_file << "        ";
                    assert(index<new_faces_data.size());
                    for(unsigned k=0; k<new_faces_data[index].size(); k++)
                    {
                        *p_file << new_faces_data[index][k] << ", ";
                    }
                    *p_file << "\n";
                    index++;
                }
            }
        }

        *p_file << inventor_footer;
    }
};

#endif /*INVENTORVORONOIWRITER_HPP_*/
